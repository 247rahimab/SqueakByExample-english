% $Author$
% $Date$
% $Revision$
% $Id$
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Seaside}
\label{cha:seaside}

%=================================================================
\section{What is Seaside?}

\ind{Seaside} is a web application framework for Smalltalk originally developed by Avi Bryant in 2002.
\index{Bryant, Avi}
A couple of the better known applications of Seaside are \ind{SqueakSource}\footnote{\url{http://SqueakSource.com}} and \ind{Dabble DB}\footnote{\url{http://DabbleDB.com}}.

Modern \ind{web application development} frameworks have to cope with a host of problems. Expressing non-trivial control flows across multiple web pages is often cumbersome. Many web applications forbid the use of the browser's ``back'' button due to the difficulty of keeping track of the state of a session. Multiple control flows can also be difficult or impossible to express.

Seaside is a component-based framework that uses ``\ind{continuations}''\footnote{A \emph{continuation} represents ``the rest of the computation'' at any point in a computation. In Smalltalk, a continuation is just an object that captures the current state of the computation, and which can be resumed at any point.} to keep track of multiple points in the control flow of web applications. Continuations are managed automatically by Seaside, so web developers do not even have to be aware of the underlying machinery. It just works.

\index{Seaside!backtracking state}
\index{Seaside!transactions}
\index{Seaside!components}
Seaside makes web development easier in the following ways:
Control flow can be expressed naturally in terms of messages sends.
Seaside keeps track of the state of each user session.
The browser's ``back'' button will work\,---\,Seaside keeps track for you which web page corresponds to which point in the execution of the web application.
Backtracking of state can be enabled, so that navigation back in time will undo side-effects.
Alternatively, transaction support is available too, to prevent users from undoing permanent side-effects using the back button.
The developer does not have to encode any information in the URL\,---\,this too is managed automatically for you.

Web pages are built up from nested components, each of which may supports its own, independent control flow.
There are no HTML templates\,---\,instead valid XHTML is generated programmatically using a simple Smalltalk API.
Seaside supports Cascading Style Sheets (\ind{CSS}), so content and layout are cleanly separated.
\seeindex{Cascading Style Sheets}{CSS}

Finally, Seaside provides a convenient web-based development interface, making it easy to develop applications iteratively, debug applications interactively, and recompile and extend applications while the server is running.

%=================================================================
\section{Getting started}

The easiest way to get started is to download the ``Seaside \subind{Seaside}{One-Click Experience}'' from the Seaside \subind{Seaside}{web site}\footnote{\url{http://seaside.st}}.
This is a prepackaged version of Seaside 2.8 for \ind{Mac OSX}, \ind{Linux} and \ind{Windows}.
The same web site lists many pointers to additional resources, including documentation and tutorials.
Be warned, however, that Seaside has evolved considerably over the years, and not all available material refers to the latest version of Seaside.

An alternative to the ``one-click'' image is to download the latest \ind{Squeak Developers' Web image}\footnote{\url{http://damien.cassou.free.fr/squeak-dev.html}}, which comes with many useful tools pre-loaded.
If you are feeling more adventurous, you can install Seaside yourself into an image by following the manual \subind{Seaside}{installation} instructions on the Seaside web site.

You can turn the Seaside server on and off respectively by evaluating
\clsind{WAKom} \ct{startOn: 8080}
or
\ct{WAKom stop}.
The default \subind{Seaside}{administrator login} and password in the prepackaged installation is \lct{admin/seaside}.
To change this, simply evaluate: \clsind{WADispatcherEditor} \ct{initialize}

%:FIG seasideStartup
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{seasideStartup}
\caption{Starting up Seaside}
\label{fig:seasideStartup}
\end{center}
\end{figure}

\dothis{Start the Seaside server and open a browser to \url{http://localhost:8080/seaside/}.
What you see should look like \figref{seasideStartup}.
Now go to \lct{examples{\go}counter}.
This is a simple example of a \subind{Seaside}{counter} that can be incremented or decremented by clicking on the \ct{++} and \ct{--} links.
Play with the counter by clicking on these links.
Use your browser's ``back'' button to go back to a previous state, and then click on \ct{++} again.
Notice how the counter is correctly incremented with respect to the current displayed state, rather than the state the counter was left in when you started using the ``back'' button.}

Now notice the \subind{Seaside}{toolbar} at the bottom of the web page.
\menu{New Session} will restart the counter.
\menu{Configure} allows you to configure the binding of the URL to the underlying Seaside component.
(To close the \menu{Configure} view, click on the \menu{x} in the top right corner.)
\menu{Toggle Halos} provides you with an interface to explore the state of the running application.
\menu{Profiler} and \menu{Memory} provide you with detailed information about the run-time performance of the application.
\menu{XHTML} can be used to validate the generated web page.
\index{Seaside!halos}

%:FIG counterHalos
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counterHalos}
\caption{Halos}
\label{fig:counterHalos}
\end{center}
\end{figure}

\dothis{Select \menu{Toggle Halos}. (See \figref{counterHalos}.) At the top left you will see the text \ct{WACounter}. This is the class of the Seaside component that implements the behaviour of this web page. Next to this are three icons. The first activates a Seaside class browser opened to this class. The second opens an object inspector on the currently active instance. The third displays the \ind{CSS} style sheet for this component. At the top right you can toggle between the rendered view and the source view of the web page. Experiment with all of these buttons. Note that the source view contains active links.  Contrast the source view provided by the Halos with the source view offered by your browser.}

The class browser and object inspector available from Seaside are provided for convenience. For development purposes you will normally be working from the currently running image.

%:FIG haltingCounter
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{haltingCounter}
\caption{Halting the counter}
\label{fig:haltingCounter}
\end{center}
\end{figure}

\dothis{Open an inspector on the counter within the browser and evaluate \ct{self halt}.
Notice that the web page will stop loading.
Now switch to the Seaside image.
You should now see a pre-debugger window (\figref{haltingCounter}) open on the current instance.
Browse this instance in the debugger, and then \menu{Proceed}.
Go back to the web browser and note that the counter application is running again.}

%:FIG multiCounterHalos
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{multiCounterHalos}
\caption{Independent subcomponents}
\label{fig:multiCounterHalos}
\end{center}
\end{figure}

\dothis{Open \url{http://localhost:8080/seaside/examples/multicounter}.
You will see an application built out of a number of independent instances of the counter component.
Increment and decrement several of the counters.
Verify that they behave correctly even if you use the ``back'' button.
Toggle the halos to see how the application is built out of nested components.
Use the Seaside class browser to view the implementation.
(There should be three methods each on the class and instance sides.)
}
\index{Seaside!multi-counter}

\dothis{Point your browser to \url{http://localhost:8080/seaside/config}.
Supply the login and password \ct{admin/seaside} (or whatever you defined them to be).
Note that you can configure, copy or remove individual components.
Select \menu{Configure} next to ``examples''.
Add a new entry point called ``counter2''.
Set the root component to \clsind{WACounter}, then \menu{Save} and \menu{Close}.
Now we have a new counter installed at \url{http://localhost:8080/seaside/examples/counter2}.
Use the same configuration interface to remove this entry point.
}
\index{Seaside!configuration}

The toolbar is only available during development.
You can either use the configuration interface or the \menu{Configure} button in the toolbar to set the deployment mode from false to true.
Note that this only affects new sessions.
You can also set the deployment mode on or off globally by evaluating
\clsind{WAGlobalConfiguration} \lct{setDeploymentMode}
or
\ct{WAGlobalConfiguration setDevelopmentMode}.
\index{Seaside!deployment mode}

If you remove the config application, you can get it back by evaluating:
\clsind{WADispatcherEditor} \ct{initialize}

%=================================================================
\section{Seaside components}

Let's have a closer look at how Seaside works.

Seaside applications are built out of \subind{Seaside}{components}.
Every Seaside component should inherit directly or indirectly from \clsind{WAComponent}. (See \figref{WACounter}.)

\dothis{Define a subclass of \ct{WAComponent} called \ct{WAHelloWorld}.}

Components must know how to render themselves.
Usually this is done by implementing the method \mthind{WAPresenter}{renderContentOn:}, which gets as its argument an instance of \clsind{WAHtmlCanvas} that knows how to render html.
\index{Seaside!rendering}

\dothis{Implement the following method:}
\begin{code}{}
WAHelloWorld>>>renderContentOn: html
	html text: 'hello world'
\end{code}

Now we must inform Seaside that this component is allowed to be a standalone application.

\dothis{Implement the following method on the class side of \ct{WAHelloWorld}.}

\begin{code}{}
WAHelloWorld class>>>canBeRoot
	^ true
\end{code}

You are almost done now.

\dothis{Go to \url{http://localhost:8080/seaside/config}, add a new entry point called ``hello'', and set its root component to be \ct{WAHelloWorld}.
Now point your browser to \url{http://localhost:8080/seaside/hello}.
That's it!}

%:FIG WAHelloWorld
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WAHelloWorld}
\caption{``Hello World'' in Seaside}
\label{fig:WAHelloWorld}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Simple and nested components}

The counter and multi-counter examples are only slightly more complex than the ``hello world'' application.

%:FIG WACounter
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WACounter}
\caption{WACounter}
\label{fig:WACounter}
\end{center}
\end{figure}

The class \clsind{WACounter} is a standalone application, so it implements \mthind{WAComponent class}{canBeRoot} on the class side.
It also automatically registers itself as an application in its class-side \ct{initialize} method (see \figref{WACounter}).

\ct{WACounter} defines an instance variable \ct{count} to keep track of the state of the counter.
Since we want Seaside to synchronize the state with the browser page, \ie in case the user clicks on the browser's ``back'' button, we must inform Seaside which variables to track by implementing the \ct{states} method.
This should return an array of all objects to be tracked.
In this case \ct{WACounter} asks to track its own state by returning \ct{Array with: self}.

\paragraph{\emph{Caveat.}}
There is a subtle but important point to watch for when declaring state for backtracking.
Seaside tracks state by making a \emph{snapshot} of all the objects declared in the \ct{states} array.
\clsind{WASnapShot} is a subclass of \clsind{IdentityDictionary} that registers each object to be tracked as a key, and a (shallow) copy of its state as a value.
If the state is restored from a snapshot, all registered objects are restored to the saved value.
In the case of the counter, the state to be backed up is presumably a \clsind{SmallInteger}.
Since small integers are stored by value, not by reference, they cannot be backed up or restored!\footnote{Seaside can restore a regular object's state, but not that of a \ct{SmallInteger}\,---\,if there are many instances of the integer \ct{10}, which one should be rolled back to the value \ct{9}?}
The \ct{WACounter} instance is a regular object, however, so its state can be tracked.
This means that \ct{WACounter>>>states} must return \ct{Array with: self} and not \ct{Array with: count}.
\index{Seaside!backtracking state}
\index{WAPresenter!states@\ct{states}}

The rendering of the counter is relatively straightforward.
The current value of the counter is displayed as an html heading, and the increment and decrement operations are implemented as html anchors with callbacks to methods \ct{increase} and \ct{decrease} (not shown).

We will have a closer look at the rendering protocol in a moment.
First let us have a quick look at the \subind{Seaside}{multi-counter}.

%:FIG WAMultiCounter
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WAMultiCounter}
\caption{WAMultiCounter}
\label{fig:WAMultiCounter}
\end{center}
\end{figure}

It is also a standalone application, so it implements \mthind{WAComponent class}{canBeRoot}.
In addition, it is composite component, so Seaside requires it to declare its children by implementing a method \ct{children}, which returns an array of all the components it contains.
It trivially renders itself by rendering each of its subcomponents, separated by a horizontal rule.
Aside from instance and class-side initialization methods, there is nothing else to the multi-counter!

%-----------------------------------------------------------------
\subsection{Rendering HTML}

Seaside does not use templates to generate web pages.
Instead XTHML is generated programmatically.
We have already seen a couple of examples of how this is done.

Basically a Seaside component should implement the method \mthind{WAPresenter}{renderContentOn:}, which will be called by the framework whenever the component needs to be rendered.
This method will be passed an argument, called \ct{html}, which is a \emphind{canvas} for rendering the component.

Here are some of the most basic rendering methods:
\begin{code}{}
html text: 'hello world'.  "render a plain text string"
html html: '&ndash;'.     "render an HTML incantation"
html render: 1.              "render any object"
\end{code}

The message \ct{render:} can be sent to a canvas to render any object (using double dispatch), though it is normally used to render subcomponents.
This was the case in our multi-counter (see \figref{WAMultiCounter}).

A canvas provides a number of \emphind{brushes} that can be used to render content on the canvas.
To see the full protocol of brushes and convenience methods available, you should browse the class \clsind{WACanvas} and its subclasses.
\ct{html} is actually an instance of the subclass \clsind{WARenderCanvas}.

We have already seen the following brushes used in the counter and multi-counter examples:
\begin{code}{}
html horizontalRule.
html space.
\end{code}

%:FIG RenderingDemo
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{RenderingDemo}
\caption{RenderingDemo}
\label{fig:RenderingDemo}
\end{center}
\end{figure}

In \figref{RenderingDemo} we can see a demo of many of the basic brushes offered by Seaside.\footnote{See package \ct{SBE-SeasideDemo} in the project \url{http://www.squeaksource.com/SqueakByExample}.}
The root component \ct{SeasideDemo} simply renders its subcomponents, which are instances of \ct{SeasideHtmlDemo}, \ct{SeasideFormDemo}, \ct{SeasideEditCallDemo} and \ct{SeasideDialogDemo}.

\begin{code}{}
SeasideDemo >>>renderContentOn: html
	html heading: 'Rendering Demo'.
	html heading
		level: 2;
		with: 'Rendering basic HTML: '.
	html div
		class: 'subcomponent';
		with: htmlDemo.
	"render the remaining components ..."
\end{code}

Note the two different ways of instantiating the \ct{heading} brush.
In the first case we set the text directly by sending the message \ct{heading:}.
In the second case, we instantiate the brush by sending \ct{heading}, and then we send a cascade of messages to the brush to set its properties and render it.
This is typical for many of the available brushes.

\important{If you send a \ind{cascade} of messages to a brush, the last message sent should always be \mthind{WABrush}{with:}, which sets the content and renders the result.}

The default heading is at level 1.
We explicitly set the level of the second heading to 2.
The subcomponent is rendered as an HTML \emph{div} with the \ind{CSS} class ``subcomponent''.
(More on CSS in \secref{css}.)
Note as well that the argument to the \ct{with:} keyword message need not be a literal string, but may be another component, or even\,---\,as in the next example\,---\,a block containing further rendering actions.

The \ct{SeasideHtmlDemo} component demonstrates many of the most basic brushes.
Most of the code should be self-explanatory.

\begin{code}{}
SeasideHtmlDemo>>>renderContentOn: html 
	self renderParagraphsOn: html.
	self renderListsAndTablesOn: html.
	self renderDivsAndSpansOn: html.
	self renderLinkWithCallbackOn: html
\end{code}

It is common practice to break up long rendering methods into many helper methods, as we have done here.

\important{Don't put all your rendering code into a single method. Split it into helper methods named after the pattern \ct{render*On:}.
All rendering methods go in method category \prot{rendering}.
Don't send \ct{renderContentOn:} from your own code, use \ct{render:} instead.}

The first helper method shows how to generate HTML paragraphs, plain and emphasized text, and images.
Note that simple elements are rendered by directly specifying the text they contain, whereas as complex elements are specified using blocks.

\begin{code}{}
SeasideHtmlDemo>>>renderParagraphsOn: html 
	html paragraph: 'A plain text paragraph.'.
	html paragraph: [
		html
			text: 'A paragraph with plain text followed by a line break. ';
			break;
			emphasis: 'Emphasized text ';
			text: 'followed by a horizontal rule.';
			horizontalRule;
			text: 'An image URI: '.
		html image
			url: self squeakImageUrl;
			width: '50']
\end{code}

The next helper method shows how to generate lists and tables.
A table even uses two levels of blocks to display each of its rows and the cells within the rows.

\begin{code}{}
SeasideHtmlDemo>>>renderListsAndTablesOn: html 
	html orderedList: [
		html listItem: 'An ordered list item'].
	html unorderedList: [
		html listItem: 'An unordered list item'].
	html table: [
		html tableRow: [
			html tableData: 'A table with one data cell.']]
\end{code}

The next example shows how we can specify CSS divs and spans with class or id attributes.
Of course, the messages \ct{class:} and \ct{id:} can also be sent to the other brushes, not just to divs and spans.
The method \ct{SeasideDemoWidget>>>style} defines the display attributes for HTML elements with these attributes (see \secref{css}).

\begin{code}{}
SeasideHtmlDemo>>>renderDivsAndSpansOn: html 
	html div
		id: 'author';
		with: [
			html text: 'Raw text within a div with id ''author''. '.
			html span
				class: 'highlight';
				with: 'A span with class ''highlight''.']
\end{code}

Finally we see a simple example of a link, created by binding a simple \subind{Seaside}{callback} to an anchor.
Clicking on the link will cause the subsequent text to toggle between ``true'' and ``false''.

\begin{code}{}
SeasideHtmlDemo>>>renderLinkWithCallbackOn: html 
	html paragraph: [
		html text: 'An anchor with a local action: '.
		html span with: [
			html anchor
				callback: [toggleValue := toggleValue not];
				with: 'toggle boolean:'].
		html space.
		html span
			class: 'boolean';
			with: (toggleValue ifTrue: ['true'] ifFalse: ['false'])]
\end{code}

\important{Note that actions should only appear in callbacks.
You should not change the state of the application while you are rendering it.}

%-----------------------------------------------------------------
\subsection{Forms}

Forms are rendered just like the other examples we have seen till now.
Here is the code for the \ct{SeasideFormDemo} component in \figref{RenderingDemo}.
\index{Seaside!HTML forms}

\begin{code}{}
SeasideFormDemo>>>renderContentOn: html
	| radioGroup |
	html heading: heading.
	html form: [
		html span: 'Heading: '.
		html textInput on: #heading of: self. "Bind this field to an instance variable."
		html select
			list: self colors;
			on: #color of: self.
		radioGroup := html radioGroup.
		html text: 'Radio on:'.
		radioGroup radioButton
			selected: radioOn;
			callback: [radioOn := true].
		html text: 'off:'.
		radioGroup radioButton
			selected: radioOn not;
			callback: [radioOn := false].
		html checkbox on: #checked of: self.
		html submitButton
			text: 'done'
		]
\end{code}{}

Since a form is a complex entity, it is rendered using a block.
Note that state changes are all specified as callbacks.

There is one Seaside trick here that is worth special mention, namely the message \mthind{WAAnchorTag}{on:of:}, which is used to bind the text input field to the variable \ct{heading}.
Anchors and buttons also support this protocol.
The first argument is the name of an instance variable for which accessors have been defined, and the second argument is the object to which this instance variable belongs.
In the case here of a text input field, this saves us the trouble if having to define a callback which updates the field as well as having to bind the default contents of the field to the current value.
The \ct{heading} variable is automatically updated whenever we update the text field.

The same trick is used twice more in this example, to cause the selection of a color to automatically update the \ct{color} variable, and to bind the result of checking the checkbox to value of the \ct{checked} variable.

Many further examples are available directly in the functional tests for Seaside.
Have a look at the system category \scat{Seaside-Tests-Functional}, or just point your browser to \url{http://localhost:8080/seaside/tests/alltests}.
The \menu{Form Elements} example illustrates most of the features of forms.

Don't forget, if you \menu{Toggle Halos}, you can directly browse all the source code of the examples on line using the Seaside class browser

%-----------------------------------------------------------------
\subsection{Cascading style sheets}
\label{sec:css}

Cascading Style Sheets\footnote{\url{http://www.w3.org/Style/CSS/}}, or \ind{CSS} for short, provide a very elegant way to separate style from content.
Seaside relies on CSS to avoid cluttering your rendering code with layout considerations.

You can set the CSS style sheet for your web components by defining the method \ct{style}, which should return a string containing the CSS rules for that component.
The styles of all the components displayed on a web page are joined together, so each component can have its own style.
It is more usual, however, to define an abstract class for your web application that defines a common style for all its subclasses.

Actually, for deployed applications, it is even more common to define style sheets as external files.
(Have a look at \clsind{WAFileLibrary}, which provides a way to serve static files without the need for a standalone server.)

If you already are familiar with CSS, then that's all you need to know.
Otherwise, read on for a very brief introduction to CSS.

Basically a CSS style sheet consists of a set of rules that specify how to format given HTML elements.
Each rule consists of two parts.
There is a \emph{selector} that specifies which HTML elements the rule applies to, and there is a \emph{declaration} which sets a number of attributes for that element.

%:FIG democss
\begin{figure}[tb]
\begin{code}{}
SeasideDemoWidget>>>style
	^ '
body {
	font: 10pt Arial, Helvetica, sans-serif, Times New Roman;
}
h2 {
	font-size: 12pt;
	font-weight: normal;
	font-style: italic;
}
table { border-collapse: collapse; }
td {
	border: 2px solid #CCCCCC;
	padding: 4px;
}
#author {
	border: 1px solid black;
	padding: 2px;
	margin: 2px;
}
.subcomponent {
	border: 2px solid lightblue;
	padding: 2px;
	margin: 2px;
}
.highlight { background-color: yellow; }
.boolean { background-color: lightgrey; }
.field { background-color: lightgrey; }
'
\end{code}
\caption{\lct{SeasideDemoWidget} common style sheet.
\label{fig:democss}}
\end{figure}
\figref{democss} illustrates a particularly simply style sheet for the rendering demo.
The first rule specifies a preference for the fonts to use for the \emph{body} of the web page.
The next few rules specify properties of second-level headings, tables, and table data.

The remaining rules have selectors which will match HTML elements that have the given ``id'' or ``class'' attributes.
The main difference between these two is that many elements may have the same class, but only one element may have a given id (\ie an \emph{identifier} must identify a \emph{unique} element on the page, such as a menu, last modified date, or author, whereas a class attribute, such as highlighted text, may occur multiple times on any page).

This style sheet expects at most one element to specify the \emph{author} of the web page.
To match an id, the selector should include the name of the id preceded by a \ct{#}.
A class name should be preceded by a dot.

Selector conditions may be combined, so the selector \ct{div.subcomponent} will only match an HTML element if it is both a div \emph{and} it has a class attribute equal to ``subcomponent''.

It is also possible to specify nested elements, though this is seldom necessary.
For example, the selector ``\ct{p span}'' will only match a span within a paragraph.

There are numerous books and web sites to help you learn CSS.
For a dramatic demonstration of the power of CSS, we recommend you to have a look at the CSS Zen Garden\footnote{\url{http://www.csszengarden.com/}}, which shows how the same content can be rendered in radically different ways simply by changing the CSS style sheet.

%-----------------------------------------------------------------
\subsection{Managing control flow}

Seaside makes it particularly easy to design web applications with non-trivial control flow.
There are basically two mechanisms that you can use:

\begin{enumerate}
  \item A component \ct{caller} can be temporarily replaced by another component, \ct{callee}, by sending \ct{caller call: callee}.
  The caller is usually \ct{self}, but could also be a subcomponent.
  The callee returns control by sending \ct{answer:}.

  \item A \emphsubind{Seaside}{task} is a special kind of component that subclasses \clsind{WATask} (instead of \clsind{WAComponent}).
  Instead of defining \ct{renderContentOn:}, it defines no content of its own, but rather defines a \ct{go} method that sends a series of \ct{call:} messages to activate various subcomponents in turn.
\end{enumerate}
\index{Seaside!control flow}

%-----------------------------------------------------------------
\subsubsection{Call and answer}

\mthind{WAComponent}{call:} and \mthind{WAComponent}{answer:} should never be used while rendering.
They may safely be sent from within a \subind{Seaside}{callback}, or from with the \mthind{WATask}{go} method of a task.

There is a trivial example of \ct{call:} and \ct{answer:} in the rendering demo of \figref{RenderingDemo}.
The component \ct{SeasideEditCallDemo} displays a text field and an \emph{edit} link.
The callback for the edit link calls a new instance of \ct{SeasideEditAnswerDemo} initialized to the value of the text field.
The callback also updates this text field to the result which is sent as an answer.

\begin{code}{}
SeasideEditCallDemo>>>renderContentOn: html 
	html span
		class: 'field';
		with: self text.
	html space.
	html anchor
		callback: [self text: (self !\underline{call:}! (SeasideEditAnswerDemo new text: self text))];
		with: 'edit'
\end{code}{}

What is particularly elegant is that the code makes absolutely no reference to a new web page that must be created.
At run-time, only the \ct{SeasideEditCallDemo} component will be replaced.
The parent component and the other peer components are otherwise untouched by the call.

The \ct{SeasideEditAnswerDemo} component is also remarkably simple.
It just renders a form with a text field.
The ``submit'' button is bound to a callback that will answer the final value of the text field.

\begin{code}{}
SeasideEditAnswerDemo>>>renderContentOn: html
	html form: [
		html textInput
			on: #text of: self.
		html submitButton
			callback: [ self !\underline{answer:}! self text ];
			text: 'ok'.
		]
\end{code}{}

That's it.

Seaside takes care of the control flow and the correct rendering of all the components.
Interestingly, the ``back'' button of the browser will also work just fine (though side effects are not rolled back unless we take additional steps).

%-----------------------------------------------------------------
\subsubsection{Convenience methods}

Since certain call/answer dialogues are very common, Seaside provides some convenience methods to save you the trouble of writing components like \ct{SeasideEditAnswerDemo}.
We can see the following convenience methods being used within \ct{SeasideDialogDemo>>>renderContentOn}
\index{Seaside!convenience methods}

%:FIG dialogs
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{dialogs}
\caption{Some standard dialogs}
\label{fig:dialogs}
\end{center}
\end{figure}

The message \mthind{WAComponent}{request:} performs a call to a component that will let you edit a text field.
The component answers the edited string.
(See \figref{dialogs}.)
An optional label and default value may also be specified.

\needlines{3}
\begin{code}{}
html anchor
	callback: [ self request: 'edit this' label: 'done' default: 'some text' ];
	with: 'self request:'.
\end{code}

The message \mthind{WAComponent}{inform:} calls a component that simply displays the argument message and waits for the user to click ``ok''.
The called component just returns \ct{self}.

\begin{code}{}
html space.
html anchor
	callback: [ self inform: 'yesBANG' ];
	with: 'self inform:'.
\end{code}

The message \mthind{WAComponent}{confirm:} asks a questions and waits for the user to select either ``Yes'' or ``No''.
The component answers a boolean, which can be used to perform further actions.

\begin{code}{}
html space.
html anchor
	callback: [
		(self confirm: 'Are you happy?')
			ifTrue: [ self inform: ':-)' ]
			ifFalse: [ self inform: ':-(' ]
		];
	with: 'self confirm:'.
\end{code}

A few further convenience methods, such as \mthind{WAComponent}{chooseFrom:caption:}, are defined in the \prot{convenience} protocol of \clsind{WAComponent}.

%-----------------------------------------------------------------
\subsubsection{Tasks}

A \subind{Seaside}{task} is a component that subclasses \clsind{WATask}.
It does not render anything itself, but simply calls other components in a control flow defined by implementing the method \mthind{WATask}{go}.

\clsind{WAConvenienceTest} is a simple example of a task defined in the system category \scat{Seaside-Tests-Functional}.
To see its effect, just point your browser to \url{http://localhost:8080/seaside/tests/alltests} and select \menu{Convenience}.

\begin{code}{}
WAConvenienceTest>>>go
	[ self chooseCheese.
	  self confirmCheese ] whileFalse.
	self informCheese
\end{code}

This task calls in turn three components.
The first is a \clsind{WAChoiceDialog} to choose a cheese (generated by the convenience method \mthind{WAComponent}{chooseFrom:caption:}).

\begin{code}{}
WAConvenienceTest>>>chooseCheese
	cheese := self
		chooseFrom: #('Greyerzer' 'Tilsiter' 'Sbrinz')
		caption: 'What''s your favorite Cheese?'.
	cheese isNil ifTrue: [ self chooseCheese ]
\end{code}

The second is a \clsind{WAYesOrNoDialog} to confirm the choice (generated by the convenience method \mthind{WAComponent}{confirm:}).
Finally a \clsind{WAFormDialog} is called (via the convenience method \mthind{WAComponent}{inform:}).

%:FIG chooseCheese
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth]{chooseCheese}
\caption{A simple task}
\label{fig:chooseCheese}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsubsection{Transactions}

We have already seen that Seaside can keep track of the correspondence between the state of components and individual web pages by having components register their state for backtracking.
It suffices to implement the method \ct{states} and have it return an array of all the objects whose state must be tracked (\ie by having Seaside make shallow copies of these objects).

Sometimes, however, we do not want to track state, but rather \emph{prevent} the user from accidentally undoing side effects that should be permanent.
This is often referred to as ``the shopping cart problem''.
Once you have checked out you shopping cart on a e-store and paid for the items you have purchased, it should not be possible to go back with the browser and add more items to the shopping cart!

Seaside allows you to prevent this by defining a task within which certain actions are grouped together as \emph{transactions}.
You can backtrack within a transaction, but once a transaction is complete, you can no longer go back to it.
The corresponding pages are \emph{invalidated}, and any attempt to go back to them will cause Seaside to generate an error.

%:FIG sushiStore
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{sushiStore}
\caption{The Sushi Store}
\label{fig:sushiStore}
\end{center}
\end{figure}

The Seaside \emphsubind{Seaside}{Sushi Store} is sample application that illustrates many of the features of Seaside, including transactions.
It should be bundled together with your installation of Seaside, in which case you can try it out by pointing your browser at
\url{http://localhost:8080/seaside/examples/store}.\footnote{If you cannot find it in your image, there is a version of the sushi store available on SqueakSource from \url{http://www.squeaksource.com/SeasideExamples/}.}

The sushi store supports the following workflow:
\begin{itemize}
  \item Visit the store.
  \item Browse or search for sushi.
  \item Add sushi to your shopping cart.
  \item Checkout.
  \item Verify your order.
  \item Enter shipping address.
  \item Verify shipping address.
  \item Enter payment information.
  \item Your fish is on its way!
\end{itemize}

If you toggle the \subind{Seaside}{halos}, you will see that the top-level component of the sushi store is an instance of \clsind{WAStore}.
It does nothing but render the title bar, and then it renders an instance of \clsind{WAStoreTask}.

\begin{code}{}
WAStore>>>renderContentOn: html
	"... render the title bar ..."
	html div id: 'body'; with: task
\end{code}

\clsind{WAStoreTask} actually capture the workflow above.
At a couple of points it is critical that you not be able to go back and change the submitted information.

\dothis{\,``Purchase'' some sushi and then use the ``back'' button to try put more sushi into your cart.
You will get the message ``That page has expired.''}

Seaside allows you to express that certain part of a workflow act like a transaction\,---\,once the transaction is complete, you cannot go back.
You can specify this very simply in a task by sending \mthind{WAComponent}{isolate:} to the task with the transactional block as its argument.
We can see this in the sushi store workflow as follows:

\begin{code}{}
WAStoreTask>>>go
	| shipping billing creditCard |
	cart := WAStoreCart new.
	self isolate:
		[[self fillCart.
		self confirmContentsOfCart]
			whileFalse].

	self isolate:
		[shipping := self getShippingAddress.
		billing := (self useAsBillingAddress: shipping)
					ifFalse: [self getBillingAddress]
					ifTrue: [shipping].
		creditCard := self getPaymentInfo.
		self shipTo: shipping billTo: billing payWith: creditCard].

	self displayConfirmation.
\end{code}

Here we see quite clearly that there are two transactions.
The first fills the cart and closes the shopping phase.
(The helper methods \ct{fillCart} \etc take care of instantiating and calling the right subcomponents.)
Once you have confirmed the contents of the cart you cannot go back without starting a new session.
The second transaction completes the shipping and payment data.
You can navigate back and forth within the second transaction until you confirm payment.
then both transactions are complete, and any attempt to navigate back will fail.

Transactions may also be nested.

A simple demonstration of this is found in the class \clsind{WANestedTransaction}.
The argument block to the first \ct{isolate:} send contains itself another, nested \ct{isolate:} send:

\begin{code}{}
WANestedTransaction>>>go
	self inform: 'Before parent txn'.
	self isolate:
			[self inform: 'Inside parent txn'.
			self isolate: [self inform: 'Inside child txn'].
			self inform: 'Outside child txn'].
	self inform: 'Outside parent txn'
\end{code}

\dothis{Go to \url{http://localhost:8080/seaside/tests/alltests} and select \menu{Convenience} and select \menu{Transaction}.
Try to navigate back and forth within the parent and child transaction.
Note that as soon as a transaction is complete, you can no longer go back inside the transaction without generating an error.}

%=================================================================
\section{A complete tutorial example}

% ON: Should take about two hours

Let's see how we can build a complete Seaside application from scratch.\footnote{The exercise should take at most a couple of hours. If you prefer to just look at the completed source code, you can grab it from the SqueakSource project \url{http://www.squeaksource.com/SqueakByExample}.
The relevant category is \scat{SBE-SeasideRPN}.}
We will build a RPN (Reverse Polish Notation) calculator as a Seaside application that uses a simple stack machine as its underlying model.
Furthermore, the Seaside interface will let us toggle between two displays\,---\,one which just shows us the current value on top of the stack, and the other which shows us the complete state of the stack.
(See \figref{stackMachine}.)

%:FIG stackMachine
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth]{stackMachine}
\caption{RPN calculator and its stack machine}
\label{fig:stackMachine}
\end{center}
\end{figure}

We begin by implementing the stack machine and its tests.

\dothis{Define a new class called \ct{StackMachine} with an instance variable \ct{contents} initialized to a new \ct{OrderedCollection}.}

\begin{code}{}
StackMachine>>>initialize
	super initialize.
	contents := OrderedCollection new.
\end{code}

The stack machine should provide operations to \ct{push:} and \ct{pop} values, view the \ct{top} of the stack, and perform various arithmetic operations to add, subtract, multiply and divide the top values on the stack.

\dothis{Write some tests for the stack operations, and then implement these operations.
Here is a sample test:}

\begin{code}{}
StackMachineTest>>>testDiv
	stack
		push: 3;
		push: 4;
		div.
	self assert: stack size = 1.
	self assert: stack top = (4/3).
\end{code}

You might consider using some helper methods for the arithmetic operations to check that there are two numbers on the stack before doing anything, and raising an error if this precondition is not fulfilled.\footnote{Better yet, use \ct{Object>>>assert:} to specify the preconditions for each operation.
This will raise an \ct{AssertionFailure} if you try to use the stack machine in an invalid state.}
If you do this, most  of your methods will just be one or two lines long.

You might also consider implementing \ct{StackMachine>>>printOn:} to make it easier to debug your stack machine implementation with the help of an object inspector.
(Hint: just delegate printing to the \ct{contents} variable.)
\index{Object!printOn:@\ct{printOn:}}

\dothis{Complete the \ct{StackMachine} by writing operations \ct{dup} (push a duplicate of the top value onto the stack), \ct{exch} (exchange the top two values), and \ct{rotUp} (rotate the entire stack contents up\,---\,the top value will move to the bottom).}

Now we have a simple stack machine implementation.
We can start to implement the Seaside RPN Calculator.

We will make use of 5 classes:
\begin{itemize}
  \item \ct{RPNWidget}\,---\,this should be an abstract class that defines the common CSS style sheet for the application
  \item \ct{RPNCalculator}\,---\,this is the root component.
  It should register the application (on the class side), it should instantiate and render its subcomponents, and it should register any state for backtracking.
  \item \ct{RPNKeyPad}\,---\,this displays the keys that we use to interact with the calculator.
  \item \ct{RPNDisplay}\,---\,this component displays the top of the stack and provides a button to call another component to display the detailed view.
  \item \ct{RPNDisplayStack}\,---\,this component shows the detailed view of the stack and provides a button to answer back.
\end{itemize}

\dothis{Define \ct{RPNWidget} and the common \ct{style}.}

Here is a minimal CSS for the application.
You can make it more fancy if you like.
\begin{code}{}
RPNWidget >>>style
	^ 'table.keypad { float: left; }
td.key {
	border: 1px solid grey;
	background: lightgrey;
	padding: 4px;
	text-align: center;
}
table.stack { float: left; }
td.stackcell {
	border: 2px solid white;
	border-left-color: grey;
	border-right-color: grey;
	border-bottom-color: grey;
	padding: 4px;
	text-align: right;
}
td.small { font-size: 8pt; }'
\end{code}

\dothis{Define \ct{RPNCalculator} to be a root component and register itself as an application.
Implement \ct{RPNCalculator>>>renderContentOn:} to render something trivial, and verify that the application runs in a browser.
}

\dothis{
\ct{RPNCalculator} is responsible for instantiating \ct{StackMachine}, \ct{RPNKeyPad} and \ct{RPNDisplay}.
Define \ct{RPNKeyPad} and \ct{RPNDisplay} as subclasses of \lct{RPNWidget}.
All three components will need access to a common instance of the stack machine, so define the instance variable \ct{stackMachine} and an initialization method \ct{setStackMachine:} in the common parent, \ct{RPNWidget}.
Add instance variables \ct{keypad} and \ct{display} to \ct{RPNCalculator} and initialize them in \ct{RPNCalculator>>>initialize}.
(Don't forget to send \lct{super initialize}!)
Pass the shared instance of the stack machine to the keypad and the display in the same initialize method.
Implement \ct{RPNCalculator>>>renderContentOn:} to simply render in turn the keypad and the display.
To correctly display the subcomponents, you must implement \ct{RPNCalculator>>>children} to return an array with the keypad and the display.
Implement placeholder rendering methods for the keypad and the display and verify that the calculator now displays its two subcomponents.
}

\dothis{
Change the implementation of the display to show the top value of the stack.
Use a table with class ``keypad'' containing a row with a single table data cell with class ``stackcell''.
Change the rendering method of the keypad to ensure that the number 0 is pushed on the stack in case it is empty.
(Define and use \ct{RPNKeypad>>>ensureStackMachineNotEmpty}.)
Also make it display an empty table with class ``keypad''.
Now the calculator should display a single cell containing the value 0.
If you toggle the halos, you should see something like this:
}

%:FIG firstStackDisplay
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{firstStackDisplay}
\caption{Displaying the top of the stack}
\label{fig:firstStackDisplay}
\end{center}
\end{figure}

\dothis{
Now let's implement an interface to interact with the stack.
First define the following helper methods, which will make it easier to script the interface:
}

\begin{code}{}
RPNKeypad>>>renderStackButtonOn: html with: text callback: aBlock colSpan: anInteger 
	(html tableData)
		class: 'key';
		colSpan: anInteger;
		with: 
				[(html anchor)
					callback: aBlock;
					with: [html html: text]]
\end{code}


\begin{code}{}
RPNKeypad>>>renderStackButtonOn: html with: text callback: aBlock 
	self 
		renderStackButtonOn: html
		with: text
		callback: aBlock
		colSpan: 1
\end{code}

We will use these two methods to define the buttons on the keypad with appropriate callbacks.
Certain buttons may span multiple columns, but the default is to occupy just one column.

\dothis{
Use the two helper methods to script the keypad as follows:
}


\begin{code}{}
RPNKeypad>>>RPNKeypad>>>renderContentOn: html 
  self ensureStackNotEmpty.
  html table
    class: 'keypad';
    with: [
      html tableRow: [
        self renderStackButtonOn: html with: '+' callback: [self stackOp: #add].
        self renderStackButtonOn: html with: '&ndash;' callback: [self stackOp: #min].
        self renderStackButtonOn: html with: '&times;' callback: [self stackOp: #mul].
        self renderStackButtonOn: html with: '&divide;' callback: [self stackOp: #div].
        self renderStackButtonOn: html with: '&plusmn;' callback: [self stackOp: #neg]].
      html tableRow: [
        self renderStackButtonOn: html with: '1' callback: [self type: '1'].
        self renderStackButtonOn: html with: '2' callback: [self type: '2'].
        self renderStackButtonOn: html with: '3' callback: [self type: '3'].
        self renderStackButtonOn: html with: 'Drop' callback: [self stackOp: #pop]
              colSpan: 2].
" ... and so on ..."
      html tableRow: [
        self renderStackButtonOn: html with: '0' callback: [self type: '0']
              colSpan: 2.
        self renderStackButtonOn: html with: 'C' callback: [self stackClearTop].
        self renderStackButtonOn: html with: 'Enter' callback: [self stackOp: #dup]
              colSpan: 2]]

\end{code}

Check that the keypad displays properly.
If you try to click on the keys, however, you will find that the calculator does not work yet ...

\dothis{
Implement \ct{Keypad>>>type:} to update the top of the stack by appending the typed digit.
You will need something like this:
}
\begin{code}{}
RPNKeypad>>>type: aString
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}
Now when you click on the digit keys the display should be updated.
(Be sure that \ct{StackMachine>>>pop} returns the value popped, or this will not work!)


\dothis{Now we must implement \ct{RPNKeypad>>>stackOp:}
Something like this will do the trick:}

\begin{code}{}
RPNKeypad>>>stackOp: op
	[ stackMachine perform: op ] on: AssertionFailure do: [ ].
\end{code}

The point is that we are not sure that all operations will succeed, for example, addition will fail if we do not have two numbers on the stack.
For the moment we can just ignore such errors.
If we are feeling more ambitious later on, we can provide some user feedback in the error handler block.

\dothis{The first version of the calculator should be working now.
Try to enter some numbers by pressing the digit keys, hitting \menu{Enter} to push a copy of the current value, and entering \menu{+} to sum the top two values.}

You will notice that typing digits does not behave the way you might expect.
Actually the calculator should be aware of whether you are typing a \emph{new} number, or appending to an existing number.

\dothis{Adapt \ct{RPNKeypad>>>type:} to behave differently depending on the current typing mode.
Introduce an instance variable \ct{mode} which takes on one of the three values \lct{typing} (when you are typing), \lct{push} (after you you have performed a calculator operation and typing should force the top value to be pushed), or \lct{clear} (after you have performed \menu{Enter} and the top value should be cleared before typing).
The new \ct{type:} method might look like this:
}

\begin{code}{}
RPNKeypad>>>type: aString
	self inPushMode ifTrue: [
		stackMachine push: stackMachine top.
		self stackClearTop ].
	self inClearMode ifTrue: [ self stackClearTop ].
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}

Typing might work better now, but it is still frustrating not to be able to see what is on the stack.

\dothis{
Define \ct{RPNDisplayStack} as a subclass of \ct{RPNDisplay}.
Add a button to the rendering method of \ct{RPNDisplay} which will call a new instance of \ct{RPNDisplayStack}.
You will need an html anchor that looks something like this:
}

\begin{code}{}
html anchor
	callback: [ self call: (RPNDisplayStack new setStackMachine: stackMachine)];
	with: 'open'
\end{code}

\dothis{
Define the rendering method of \ct{RPNDisplayStack} to display all of the values on the stack.
(You will either need to define an accessor for the stack machine's \ct{contents} or you can define \ct{StackMachine>>>do:} to iterate over the stack values.)
The stack display should also have a button whose callback will simply form \ct{self answer}.
}

Now you should be able to \emph{open} and \emph{close} the stack while you are using the calculator.

There is, however, one thing we have forgotten.
Try to perform some operations on the stack.
Now use the ``back'' button of your browser and try to perform some more stack operations.
(For example, \menu{open} the stack, type \menu{1}, \menu{Enter} twice and \menu {+}.
The stack should display ``2'' and ``1''.
Now hit the ``back'' button.
The stack now shows three times ``1'' again.
Now if you type \menu{+} the stack shows ``3''.
Backtracking is not yet working.

\dothis{
Implement \ct{RPNCalculator>>>states} to return the contents of the stack machine.
Verify that backtracking now works correctly!
}

Sit back and enjoy a tall glass of something cool!

%=================================================================
\section{Chapter summary}

\begin{itemize}
  \item The easiest way to get started is to download the ``Seaside One-Click Experience'' from \url{http://seaside.st}
  \item Turn the server on and off by evaluating \ct{WAKom startOn: 8080} and \ct{WAKom stop}.
  \item Reset the administrator login and password by evaluating \ct{WADispatcherEditor initialize}.
  \item \menu{Toggle Halos} to directly view application source code, run-time objects, CSS and XHTML.
  \item Send \ct{WAGlobalConfiguration setDeploymentMode} to hide the toolbar.
  \item Seaside web applications are composed of components, each of which is an instance of a subclass of \ct{WAComponent}.
  \item Only a root component may be registered as a component. It should implement \ct{canBeRoot} on the class side. Alternatively it may register itself as an application in its class-side \ct{initialize} method by sending \ct{self registerAsApplication:} \emph{application name}.
  \item To backtrack state, a component must implement the \ct{states} method to return an array of objects whose state must be restored if the user clicks the browsers ``back'' button. (\emph{Caveat:}  To be backed up and restored, the state objects must be real objects accessed by reference, not small integers!)
  \item A component renders itself by implementing \ct{renderContentOn:}.
  The argument to this method is an HTML rendering \emph{canvas} (usually called \ct{html}).
  \item A component can render a subcomponent by sending \ct{self render} \emph{subcomponent}.
  \item XHTML is generated programmatically by sending messages to \emph{brushes}. A brush is obtained by sending a message, such as \ct{paragraph} or \ct{div} to the html canvas.
  \item If you send a cascade of messages to a brush, the last message sent should always be \ct{with:}, which sets the content and renders the result.
  \item Actions should only appear in callbacks.
You should not change the state of the application while you are rendering it.
  \item You can bind various form widgets and anchors to th evalues of instance variables by sending the message \ct{on:} \emph{instance variable} \ct{of:} \emph{object} to the brush.
  \item You can define the CSS for a component hierarchy by defining the method \ct{style}, which should return a string containing the style sheet.
  (For deployed applications, it is more usual to refer to a style sheet located at a static URL.)
  \item Control flows can be programmed by sending \ct{x call: y}, in which case component \ct{x} will be replaced by \ct{y} untill \ct{y} answers by sending \ct{answer:} with a result in a callback.
  The receiver of \ct{call:} is usually \ct{self} or a subcomponent.
  \item A control flow can also be specified as a \emph{task}\,---\,a instance of a subclass of \ct{WATask}. It should implement the method \ct{go}, which should call a series of components in a workflow.
  \item Use \ct{WAComponents}'s convenience methods \ct{request:}, \ct{inform:}, \ct{confirm:} and \ct{chooseFrom:caption:} for basic interactions.
  \item To prevent the user from using the browser's ``back'' button to access a previous execution state of the web application, you can declare portions of the workflow to be a \emph{transaction} by enclosing them in an \ct{isolate:} block.
\end{itemize}
%-----------------------------------------------------------------

%=================================================================
\ifx\wholebook\relax\else 
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=================================================================
