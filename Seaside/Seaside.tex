% $Author$
% $Date$
% $Revision$
% $Id$
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{Seaside}
\label{cha:seaside}

\on{I am working on this chapter.}

%=================================================================
\section{What is Seaside?}

Seaside is a web application framework for Smalltalk originally developed by Avi Bryant in 2002.
A couple of the better known applications of Seaside are SqueakSource\cite{SqueakSource} and Dabble DB\cite{DabbleDB}.

Modern web application development frameworks have to cope with a host of problems. Expressing non-trivial control flows across multiple web pages is often cumbersome. Many web applications forbid the use of the browser's ``back button'' due to the difficulty of keeping track of the state of a session. Multiple control flows can also be difficult or impossible to express.

Seaside is a component-based framework that uses ``continuations''\footnote{A \emph{continuation} represents ``the rest of the computation'' at any point in a computation. In Smalltalk, a continuation is just an object that captures the current state of the computation, and which can be resumed at any point.} to keep track of multiple points in the control flow of web applications. Continuations are managed automatically by Seaside, so web developers do not even have to be aware of the underlying machinery. It just works.

Seaside makes web development easier in the following ways:
Control flow can be expressed naturally in terms of messages sends.
Seaside keeps track of the state of each user session.
The browser's ``back button'' will work\,---\,Seaside keeps track for you which web page corresponds to which continuation.
Backtracking of state can be enabled, so that navigation back in time will undo side-effects.
Alternatively, transaction support is available too, to prevent users from undoing permanent side-effects using the back button.
The developer does not have to encode any information in the URL\,---\,this too is managed automatically for you.
Web pages are built up from nested components, each of which may supports its own, independent control flow.
There are no HTML templates\,---\,instead valid XHTML is generated using a simple Smalltalk API.
Seaside supports Cascading Style Sheets (CSS), so content and layout are cleanly separated.
Finally, Seaside provides a convenient web-based development interface, making it easy to develop applications iteratively, debug applications interactively, and recompile and extend applications while the server is running.

%=================================================================
\section{Getting started}

The easiest way to get started is to download the ``Seaside One-Click Experience'' from the Seaside web site\cite{Seaside}.
This is a prepackaged version of Seaside 2.8 for Mac OSX, Linux and Windows.
The same web site lists many pointers to additional resources, including documentation and tutorials.
Be warned, however, that Seaside has evolved considerably over the years, and not all available material refers to the latest version of Seaside.

An alternative to the ``one-click'' image is to download the latest Squeak Developers' Web image\cite{SqueakDevImage}, which comes with many useful tools pre-loaded.
If you are feeling more adventurous, you can install Seaside yourself into an image by following the manual installation instructions on the Seaside web site.

You can turn the Seaside server on and off respectively by evaluating
\ct{WAKom startOn: 8080}
or
\ct{WAKom stop}.
The default administrator login and password in the prepackaged installation is \lct{admin/seaside}.
To change this, simply evaluate: \lct{WADispatcherEditor initialize}

%:FIG seasideStartup
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{seasideStartup}
\caption{Starting up Seaside}
\label{fig:seasideStartup}
\end{center}
\end{figure}

\dothis{Start the Seaside server and open a browser to \url{http://localhost:8080/seaside/}.
What you see should look like \figref{seasideStartup}.
Now go to \lct{examples{\go}counter}.
This is a simple example of a counter that can be incremented or decremented by clicking on the \ct{++} and \ct{--} links.
Play with the counter by clicking on these links.
Use your browser's ``back button'' to go back to a previous state, and then click on \ct{++} again.
Notice how the counter is correctly incremented with respect to the current displayed state, rather than the state the counter was left in when you started using the ``back'' button.}

Now notice the toolbar at the bottom of the web page.
\menu{New Session} will restart the counter.
\menu{Configure} allows you to configure the binding of the URL to the underlying Seaside component.
(To close the \menu{Configure} view, click on the \menu{x} in the top right corner.)
\menu{Toggle Halos} provides you with an interface to explore the state of the running application.
\menu{Profiler} and \menu{Memory} provide you with detailed information about the run-time performance of the application.
\menu{XHTML} can be used to validate the generated web page.

%:FIG counterHalos
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counterHalos}
\caption{Halos}
\label{fig:counterHalos}
\end{center}
\end{figure}

\dothis{Select \menu{Toggle Halos}. (See \figref{counterHalos}.) At the top left you will see the text \ct{WACounter}. This is the class of the Seaside component that implements the behaviour of this web page. Next to this are three icons. The first activates a Seaside class browser opened to this class. The second opens an object inspector on the currently active instance. The third displays the CSS style sheet for this component. At the top right you can toggle between the rendered view and the source view of the web page. Experiment with all of these buttons. Note that the source view contains active links.  Contrast the source view provided by the Halos with the source view offered by your browser.}

The class browser and object inspector available from Seaside are provided for convenience. For development purposes you will normally be working from the currently running image.

%:FIG haltingCounter
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{haltingCounter}
\caption{Halting the counter}
\label{fig:haltingCounter}
\end{center}
\end{figure}

\dothis{Open an inspector on the counter within the browser and evaluate \ct{self halt}.
Notice that the web page will stop loading.
Now switch to the Seaside image.
You should now see a pre-debugger window (\figref{haltingCounter}) open on the current instance.
Browse this instance in the debugger, and then \menu{Proceed}.
Go back to the browser and note that the counter application is running again.}

%:FIG multiCounterHalos
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{multiCounterHalos}
\caption{Independent subcomponents}
\label{fig:multiCounterHalos}
\end{center}
\end{figure}

\dothis{Open \url{http://localhost:8080/seaside/examples/multicounter}.
You will see an application built out of a number of independent instances of the counter component.
Increment and decrement several of the counters.
Verify that they behave correctly even if you use the ``back'' button.
Toggle the halos to see how the application is built out of nested components.
Use the Seaside class browser to view the implementation.
(There should be three methods each on the class and instance sides.)
}

\dothis{Point your browser to \url{http://localhost:8080/seaside/config}.
Supply the login and password \ct{admin/seaside} (or whatever you defined them to be).
Note that you can configure, copy or remove individual components.
Select \menu{Configure} next to ``examples''.
Add a new entry point called ``counter2''.
Set the root component to \ct{WACounter}, then \menu{Save} and \menu{Close}.
Now we have a new counter installed at \url{http://localhost:8080/seaside/examples/counter2}.
Use the same configuration interface to remove this entry point.
}

The toolbar is only available during development.
You can either use the configuration interface or the \menu{Configure} button in the toolbar to set the deployment mode from false to true.
Note that this only affects new sessions.
You can also set the deployment mode on or off globally by evaluating
\ct{WAGlobalConfiguration setDeploymentMode}
or
\ct{WAGlobalConfiguration setDevelopmentMode}.

If you remove the config application, you can get it back by evaluating:
\ct{WADispatcherEditor initialize}

%=================================================================
\section{Seaside components}

Let's have a closer look at how Seaside works.

Seaside applications are built out of components.
Every Seaside component should inherit directly or indirectly from \ct{WAComponent}. (See \figref{WACounter}.)

\dothis{Define a subclass of \ct{WAComponent} called \ct{WAHelloWorld}.}

Components must know how to render themselves.
Usually this is done by implementing the method \ct{renderContentOn:}, which gets as its argument an instance of \ct{WAHtmlCanvas} that knows how to render html.

\dothis{Implement the following method:}
\begin{code}{}
WAHelloWorld>>>renderContentOn: html
	html text: 'hello world'
\end{code}

Now we must inform Seaside that this component is allowed to be a standalone application.

\dothis{Implement the following method on the class side of \ct{WAHelloWorld}.}

\begin{code}{}
WAHelloWorld class>>>canBeRoot
	^ true
\end{code}

You are almost done now.

\dothis{Go to \url{http://localhost:8080/seaside/config}, add a new entry point called ``hello'', and set its root component to be \ct{WAHelloWorld}.
Now point your browser to \url{http://localhost:8080/seaside/hello}.
That's it!}

%:FIG WAHelloWorld
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WAHelloWorld}
\caption{``Hello World'' in Seaside}
\label{fig:WAHelloWorld}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Simple and nested components}

The counter and multi-counter examples are only slightly more complex than the ``hello world'' application.

%:FIG WACounter
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WACounter}
\caption{WACounter}
\label{fig:WACounter}
\end{center}
\end{figure}

The class \ct{WACounter} is a standalone application, so it implements \ct{canBeRoot} on the class side.
It also automatically registers itself as an application in its class-side \ct{initialize} method (see \figref{WACounter}).

\ct{WACounter} defines an instance variable \ct{count} to keep track of the state of the counter.
Since we want Seaside to synchronize the state with the browser page, \ie in case the user clicks on the browser's ``back button'', we must inform Seaside which variables to track by implementing the \ct{states} method.
This should return an array of all objects to be tracked.
In this case \ct{WACounter} asks to track its own state by returning \ct{Array with: self}.

\paragraph{\emph{Caveat.}}
Seaside tracks state by making a \emph{snapshot} of all the state objects.
A \ct{WASnapShot} is a subclass of \ct{IdentityDictionary} that registers the object to be tracked as a key, and a (shallow) copy of its state as a value.
If the state is restored from a snapshot, all registered objects are restored to the saved value.
This means that \ct{WACounter>>>states} must return \ct{Array with: self} and not \ct{Array with: count}!  Since \ct{count} is presumably a \ct{SmallInteger} it cannot be backed up or restored. The \ct{WACounter} instance is a regular object, however, so its state can be tracked.

The rendering of the counter is relatively straightforward.
The current value of the counter is displayed as an html heading, and the increment and decrement operations are implemented as html anchors with callbacks to methods \ct{increase} and \ct{decrease} (not shown).

We will have a closer look at the rendering protocol in a moment.
First let us have a quick look at the multi-counter.

%:FIG WAMultiCounter
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WAMultiCounter}
\caption{WAMultiCounter}
\label{fig:WAMultiCounter}
\end{center}
\end{figure}

It is also a standalone application, so it implements \ct{canBeRoot}.
In addition, it is composite component, so Seaside requires it to declare its children by implementing a method \ct{children} that returns an array of all the components it contains.
It trivially renders itself by rendering each of its subcomponents, separated by a horizontal rule.
Aside from instance and class-side initialization methods, there is nothing else to the multi-counter!

%-----------------------------------------------------------------
\subsection{Rendering HTML}

Seaside does not use templates to generate web pages.
Instead XTHML is generated programmatically.
We have already seen a couple of examples of how this is done.

Basically a Seaside component should implement the method \ct{renderContentOn:}, which will be called by the framework whenever the component needs to be rendered.
This method will be passed an argument, called \ct{html}, which is a \emph{canvas} for rendering the component.

Here are some of the most basic rendering methods:
\begin{code}{}
html text: 'hello world'.  "render a plain text string"
html html: '&ndash;'.     "render an HTML incantation"
html render: 1.              "render any object"
\end{code}

The message \ct{render:} can be sent to a canvas to render any object (using double dispatch), though it is normally used to render subcomponents (as was the case in our multi-counter; see \figref{WAMultiCounter}).

A canvas provides a number of \emph{brushes} that can be used to render content on the canvas.
To see the full protocol of brushes and convenience methods available, you should browse the class \ct{WACanvas} and its subclasses.
\ct{html} is actually an instance of the subclass \ct{WARenderCanvas}.

We have already seen the following brushes used in the counter and multi-counter examples:
\begin{code}{}
html horizontalRule.
html space.
\end{code}

%:FIG RenderingDemo
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{RenderingDemo}
\caption{RenderingDemo}
\label{fig:RenderingDemo}
\end{center}
\end{figure}

\on{Regenerate the figure at higher resolution --- NB: must be a png, else the colour highlighting may be lost.}

In \figref{RenderingDemo} we can see a demo of many of the basic brushes offered by Seaside.\footnote{See package \ct{SBE-SeasidDemo} in the project \url{http://www.squeaksource.com/SqueakByExample}.}
The root component \ct{SeasideDemo} simply renders its subcomponents, which are instances of \ct{SeasideHtmlDemo}, \ct{SeasideFormDemo}, \ct{SeasideEditCallDemo} and \ct{SeasideDialogDemo}.

\begin{code}{}
SeasideDemo >>>renderContentOn: html
	html heading: 'Rendering Demo'.
	html heading
		level: 2;
		with: 'Rendering basic HTML: '.
	html div
		class: 'subcomponent';
		with: htmlDemo.
	"render the remaining components ..."
\end{code}

Note the two different ways of instantiating the \ct{heading} brush.
In the first case we set the text directly by sending the message \ct{heading:}.
In the second case, we instantiate the brush by sending \ct{heading}, and then we send a cascade of messages to the brush to set its properties and render it.
This is typical for many of the available brushes.

\important{If you send a cascade of messages to a brush, the last message sent should always be \ct{with:}, which sets the content and renders the result.}

The default heading is at level 1.
We explicitly set the level of the second heading to 2.
The subcomponent is rendered as an HTML \emph{div} with the CSS class ``subcomponent''.
(More on CSS in \secref{css}.)

The \ct{SeasideHtmlDemo} component demonstrates many of the most basic brushes.
Most of the code should be self-explanatory.
The example shows how to generate HTML paragraphs, plain and emphasized text, images, lists, tables, and divs and spans with CSS class and id attributes.
Note that simple elements are rendered by directly specifying the text they contains, whereas as complex elements are specified using blocks.
A table even uses two levels of blocks to display each of its rows and the cells within the rows.

We also see a simple example of a link, created binding a simple callback to an anchor.
Clicking on the link will cause the subsequent text to toggle between ``true'' and ``false''.

\begin{code}{}
SeasideHtmlDemo>>>renderContentOn: html
	html paragraph: 'A plain text paragraph.'.
	html paragraph: [
		html
			text: 'A paragraph with plain text followed by a line break. ';
			break;
			emphasis: 'Emphasized text ';
			text: 'followed by a horizontal rule.';
			horizontalRule;
			text: 'An image URI: '.
			html image
				url: 'https://www.iam.unibe.ch/scg/svn_repos/SqueakByExample/Book/figures/sq.png';
				width: '50'.
		].

	html orderedList: [ html listItem: 'An ordered list item' ].
	html unorderedList: [ html listItem: 'An unordered list item' ].
	html table: [ html tableRow: [ html tableData: 'A table with one data cell.' ] ].

	html div id: 'author';
		with: [
			html text: 'Raw text within a div with id ''author''. '.
			html span class: 'highlight'; with: 'A span with class ''highlight''.'. ].

	html paragraph: [
		html text: 'An anchor with a local action: '.
		html span
			with: [
				html anchor
					callback: [ toggleValue := toggleValue not ];
					with: 'toggle boolean:'
			].
		html space.
		html span
			class: 'boolean';
			with: (toggleValue ifTrue: [ 'true'] ifFalse: [ 'false' ])
		].
\end{code}{}

\important{Note that actions should only appear in callbacks.
You should not change the state of the application while you are rendering it.}

\ct{SeasideHtmlDemo>>>renderContentOn:} is unusually long as a rendering method.
We have left it like this only so that we can see a large number of examples of html rendering in a single block of code.
It is more usual to break up such methods into many helper methods.

\important{Don't put all your rendering code into a single method. Split it into helper methods named after the pattern \ct{#render*On:}.
All rendering methods go in method category \prot{rendering}.
Don't send \ct{#renderContentOn:} from your own code, use \ct{#render:} instead.}

%-----------------------------------------------------------------
\subsection{Forms}

Forms are rendered just like the other examples we have seen till now.
Here is the code for the \ct{SeasideFormDemo} component in \figref{RenderingDemo}.

\begin{code}{}
SeasideFormDemo>>>renderContentOn: html
	| radioGroup |
	html heading: heading.
	html form: [
		html span: 'Heading: '.
		html textInput on: #heading of: self. "Bind this field to an instance variable."
		html select
			list: self colors;
			on: #color of: self.
		radioGroup := html radioGroup.
		html text: 'Radio on:'.
		radioGroup radioButton
			selected: radioOn;
			callback: [radioOn := true].
		html text: 'off:'.
		radioGroup radioButton
			selected: radioOn not;
			callback: [radioOn := false].
		html checkbox on: #checked of: self.
		html submitButton
			text: 'done'
		]
\end{code}{}

Since a form is a complex entity, it is rendered using a block.
Note that state changes are all specified as callbacks.

There is one Seaside trick here that is worth special mention, namely the message \ct{#on:of:}, which is used to bind the text input field to the variable \ct{heading}.
Anchors and button also support this protocol.
The first argument is the name of an instance variable for which accessors have been defined, and the second argument is the object to which this instance variable belongs.
In the case here of a text input field, this saves us the trouble if having to define a callback which updates the field as well as having to bind the default contents of the field to the current value.

The same trick is used twice more in this example.

Many further examples are available directly in the functional tests for Seaside.
Have a look at the system category \scat{Seaside-Tests-Functional}, or just point your browser to \url{http://localhost:8080/seaside/tests/alltests}.
The \menu{Form Elements} example illustrates most of the features of forms.

Don't forget, if you \menu{Toggle Halos}, you can browse all the source code of the examples on line using the Seaside class browser

%-----------------------------------------------------------------
\subsection{Cascading style sheets}
\label{sec:css}

You can set the CSS for your web components by defined the method \ct{style}, which should return a string containing the CSS rules for that component.
The styles of all the components displayed on a web page are joined together, so each component can have its own style.
It is more usual, however, to define an abstract class for your web application that defines a common style for all its subclasses.

Actually, for deployed applications, it is even more common to define stylesheets as external files.
(You should also have a look at \ct{WAFileLibrary}, which provides a way to serve static files without the need for a standalone server.)

If you already are familiar with CSS, then that's all you need to know.
Otherwise, read on for a quick look at CSS.

Cascading Style Sheets, or CSS for short, provide a very elegant way to separate style from content.
Seaside relies on this to avoid cluttering your rendering code with layout considerations.

Basically a CSS stylesheet consists of a set of rules that specify how to format given HTML elements.
Each rule consists of two parts.
There is a \emph{selector} which specifies which HTML elements the rule applies to, and there is a \emph{declaration} which sets a number of attributes for that element.

%:FIG democss
\begin{figure}[ht]
\begin{code}{}
SeasideDemoWidget>>>style
	^ 'body {
	font: 10pt Arial, Helvetica, sans-serif, Times New Roman;
}
h2 {
	font-size: 12pt;
	font-weight: normal;
	font-style: italic;
}
table { border-collapse: collapse; }
td {
	border: 2px solid #CCCCCC;
	padding: 4px;
}
#author {
	border: 1px solid black;
	padding: 2px;
	margin: 2px;
}
.subcomponent {
	border: 2px solid lightblue;
	padding: 2px;
	margin: 2px;
}
.highlight { background-color: yellow; }
.boolean { background-color: lightgrey; }
.field { background-color: lightgrey; }'
\end{code}
\caption{\lct{SeasideDemoWidget} common stylesheet.
\label{fig:democss}}
\end{figure}
\figref{democss} illustrates a particularly simply stylesheet for the rendering demo.
The first rule specifies a preference for the fonts to use for the body of the web page.
The next few rules specify properties of second-level headings, tables, and table data.

The remaining rules have selectors which will match HTML elements that have the given ``id'' or ``class'' attributes.
The main difference between these two is that many elements may have the same class, but only one element may have a given id.

This stylesheet expects at most one element to specify the \emph{author} of the web page.
To match an id, the selector should include the name of the id starting with a \ct{#}.
A class name should be preceded by a dot.

Selector conditions may be combined, so the selector \ct{div.subcomponent} will only match an HTML element if it is both a div \emph{and} it has a class attribute equal to ``subcomponent''.

It is also possible to specify nested elements, though this is seldom necessary.
For example, the selector \ct{p span} will only match a span within a paragraph.

\on{List some web sites for more information:
W3 consortium;
CSS Zen Garden;
...}

%-----------------------------------------------------------------
\subsection{Managing control flow}

Seaside makes it particularly easy to design web applications with non-trivial control flow.
There are basically two mechanisms that you can use:

\begin{enumerate}
  \item A component can temporarily replace itself by another component by sending \ct{#call:} to that component.
  The called component can terminate with a result by sending \ct{#answer:}.

  \item A \emph{task} is a special kind of component that subclasses \ct{WATask} (instead of \ct{WAComponent}).
  Instead of defining \ct{#renderContentOn:}, it defines no content of its own, but rather defines a \ct{#go} method that sends \ct{#call:} messages to a series of components in turn.
\end{enumerate}

%-----------------------------------------------------------------
\subsubsection{Call and answer}

\ct{#call:} and \ct{answer:} should never be used while rendering.
They may safely be sent from within a callback, or from with the \ct{#go} method of a task.

There is a trivial example of \ct{#call:} and \ct{#answer:} in the rendering demo of \figref{RenderingDemo}.
The component \ct{SeasideEditCallDemo} displays a text field and an \emph{edit} link.
The callback for the edit link sends \ct{#call:} to a new instance of \ct{SeasideEditAnswerDemo} initialized to the value of the text field.
The callback also updates this text field to the result of the \ct{#call:}.

\begin{code}{}
SeasideEditCallDemo>>>renderContentOn: html 
	(html span)
		class: 'field';
		with: self text.
	html space.
	(html anchor)
		callback: 
				[self text: (self call: (SeasideEditAnswerDemo new text: self text))];
		with: 'edit'
\end{code}{}

What is particularly elegant is that the code makes absolutely no reference to a new web page that must be created.
At run-time, only the \ct{SeasideEditCallDemo} component will be replaced.
The parent component and the other peer components are otherwise untouched by the call.

The \ct{SeasideEditAnswerDemo} component is also remarkably simple.
It just renders a form with a text field.
The ``submit'' button is bound to a callback that will answer the final value of the text field.

\begin{code}{}
SeasideEditAnswerDemo>>>renderContentOn: html
	html form: [
		html textInput
			on: #text of: self.
		html submitButton
			callback: [ self answer: self text ];
			text: 'ok'.
		]
\end{code}{}

That's it.

Seaside takes care of the control flow and the correct rendering of all the components.
Interestingly, the ``back'' button of the browser will also work just fine (though side effects are not rolled back unless we take additional steps).

%-----------------------------------------------------------------
\subsubsection{Convenience methods}

Since certain call/answer dialogues are very common, Seaside provide some convenience methods to save you the trouble of writing components like \ct{SeasideEditAnswerDemo}.

%:FIG dialogs
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{dialogs}
\caption{Some standard dialogs}
\label{fig:dialogs}
\end{center}
\end{figure}

The message \ct{self request:} performs a call to a component that will let you edit a text field.
The component answers the edited string.
(See \figref{dialogs}.)
An optional label and default value may also be specified.

\begin{code}{}
(html anchor)
	callback: [ self request: 'edit this' label: 'done' default: 'some text' ];
	with: 'self request:'.
\end{code}

The message \ct{self inform:} calls a component that simply displays the argument message and waits for the user to click ``ok''.
The called component just returns \ct{self}.

\begin{code}{}
html space.
(html anchor)
	callback: [ self inform: 'yesBANG' ];
	with: 'self inform:'.
\end{code}

The message \ct{self confirm:} asks a questions and waits for the user to select either ``Yes'' or ``No''.
The component answers a boolean, which can be used to perform further actions.

\begin{code}{}
html space.
(html anchor)
	callback: [
			(self confirm: 'Are you happy?')
				ifTrue: [ self inform: ':-)' ]
				ifFalse: [ self inform: ':-(' ]
			];
	with: 'self confirm:'.
\end{code}

A few further convenience methods are defined in the \prot{convenience} protocol of \ct{WAComponent}.

%-----------------------------------------------------------------
\subsubsection{Tasks}

A task is a component that subclasses \ct{WATask}.
It does not render anything itself, but simply calls other components in a control flow defined by implementing the method \ct{#go}.

\ct{WAConvenienceTest} is a simple example of a task defined in the system category \scat{Seaside-Tests-Functional}.
To see its effect, just point your browser to \url{http://localhost:8080/seaside/tests/alltests} and select \menu{Convenience}.

\begin{code}{}
WAConvenienceTest>>>go
	[ self chooseCheese.
	  self confirmCheese ] whileFalse.
	self informCheese
\end{code}

This task calls in turn three components.
The first is a \ct{WAChoiceDialog} to choose a cheese (generated by the convenience method \ct{#chooseFrom:caption:}).
The second is a \ct{WAYesOrNoDialog} to confirm the choice (generated by the convenience method \ct{#confirm:}).
Finally a \ct{WAFormDialog} is called (via the convenience method \ct{#inform:}).

%:FIG chooseCheese
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth]{chooseCheese}
\caption{A simple task}
\label{fig:chooseCheese}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsubsection{Transactions}

We have already seen that Seaside can keep track of the correspondence between the state of components and individual web pages by having components register their state for backtracking.
It suffices to implement the method \ct{#states} and have it return an array of all the objects whose state must be tracked (\ie by having Seaside make shallow copies of these objects).

Sometimes, however, we do not want to track state, but rather prevent the user from accidentally undoing side effects that should be permanent.
This is often referred to as ``the shopping cart problem''.
Once you have checked out you shopping cart on a e-store and paid for the items you have purchased, it should not be possible to go back with the browser and add more items to the shopping cart!

Seaside allows you to prevent this by defining a task within which certain actions are grouped together as \emph{transactions}.
You can backtrack within a transaction, but once a transaction is complete, you can no longer go back to it.
The corresponding pages are \emph{invalidated}, and any attempt to go back to them will cause Seaside to generate an error.

%:FIG sushiStore
\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{sushiStore}
\caption{The Sushi Store}
\label{fig:sushiStore}
\end{center}
\end{figure}

The Seaside \emph{Sushi Store} is sample application that illustrates many of the features of Seaside, including transactions.
It should be bundled together with your installation of Seaside, in which case you can try it out by pointing your browser at
\url{http://localhost:8080/seaside/examples/store}.\footnote{If you cannot find it in your image, there is a version of the sushi store available on SqueakSource from \url{http://www.squeaksource.com/SeasideExamples/}.}

The sushi store supports the following workflow:
\begin{itemize}
  \item Visit the store.
  \item Browse or search for sushi.
  \item Add sushi to your shopping cart.
  \item Checkout.
  \item Verify your order.
  \item Enter shipping address.
  \item Verify shipping address.
  \item Enter payment information.
  \item Your fish is on its way!
\end{itemize}

If you toggle the halos, you will see that the top-level component of the sushi store is an instance of \ct{WAStore}.
It does nothing but render the title bar, and then it renders an instance of \ct{WAStoreTask}.

\begin{code}{}
WAStore>>>renderContentOn: html	"render the title bar ..."	html div id: 'body'; with: task
\end{code}

\ct{WAStoreTask} actually capture the workflow above.
At a couple of points it is critical that you not be able to go back and change the submitted information.

\dothis{``Purchase'' some sushi and then use the ``back'' button to try put more sushi into your cart.
You will get the message ``That page has expired.''}

Seaside allows you to express that certain part of a workflow act like a transaction\,---\,once the transaction is complete, you cannot go back.
You can specify this very simply in a task by sending \ct{#isolate:} to the task with the transactional block as its argument.
We can see this in the sushi store workflow as follows:

\begin{code}{}
WAStoreTask>>>go	| shipping billing creditCard |	cart := WAStoreCart new.	self isolate:		[[self fillCart.		self confirmContentsOfCart]			whileFalse].	self isolate:		[shipping := self getShippingAddress.		billing := (self useAsBillingAddress: shipping)					ifFalse: [self getBillingAddress]					ifTrue: [shipping].		creditCard := self getPaymentInfo.		self shipTo: shipping billTo: billing payWith: creditCard].	self displayConfirmation.
\end{code}

Here we see quite clearly that there are two transactions.
The first fills the cart and closes the shopping phase.
(The helper methods \ct{fillCart} \etc take care of instantiating and calling the right subcomponents.)
Once you have confirmed the contents of the cart you cannot go back without starting a new session.
The second transaction completes the shipping and payment data.
You can navigate back and forth within the second transaction until you confirm payment.
then both transactions are complete, and any attempt to navigate back will fail.

Transactions may also be nested.

A simple demonstration of this is found in the class \ct{WANestedTransaction}.
The argument block to the first \ct{isolate:} send contains itself another, nested \ct{isolate:} send:

\begin{code}{}
WANestedTransaction>>>go	self inform: 'Before parent txn'.	self isolate:			[self inform: 'Inside parent txn'.			self isolate: [self inform: 'Inside child txn'].			self inform: 'Outside child txn'].	self inform: 'Outside parent txn'
\end{code}

\dothis{Go to \url{http://localhost:8080/seaside/tests/alltests} and select \menu{Convenience} and select \menu{Transaction}.
Try to navigate back and forth within the parent and child transaction.
Note that as soon as a transaction is complete, you can no longer go back inside the transaction without generating an error.}

%=================================================================
\section{A complete example}

\on{This is just a first sketch -- we must try it out and see what additional information is needed.
Also note the total time, and the milestones where we can see something running!}

Let's see how we can build a complete Seaside application from scratch.\footnote{If you prefer to just look at the completed source code, you can grab it from the SqueakSource project \url{http://www.squeaksource.com/SqueakByExample}.
The relevant category is \scat{SBE-SeasideRPN}.}
We will build a RPN (Reverse Polish Notation) calculator as a Seaside application that uses a simple stack machine as its underlying model.
Furthermore, the Seaside interface will let us toggle between two displays\,---\,one which just shows us the current value on top of the stack, and the other which shows us the complete state of the stack.
(See \figref{stackMachine}.)

%:FIG stackMachine
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth]{stackMachine}
\caption{RPN calculator and its stack machine}
\label{fig:stackMachine}
\end{center}
\end{figure}

We begin by implementing the stack machine and its tests.

\dothis{Define a new class called \ct{StackMachine} with an instance variable \ct{contents} initialized to a new \ct{OrderedCollection}.}

\begin{code}{}
StackMachine>>>initialize	super initialize.	contents := OrderedCollection new.
\end{code}

The stack machine should provide operations to \ct{push:} and \ct{pop} values, view the \ct{top} of the stack, and perform various arithmetic operations to add, subtract, multiply and divide the top values on the stack.

\dothis{Write some tests for the stack operations, and then implement these operations.
Here is a simple test:}

\begin{code}{}
StackMachineTest>>>testDiv	stack		push: 3;		push: 4;		div.	self assert: stack size = 1.	self assert: stack top = (4/3).
\end{code}

You might consider using some helper methods for the arithmetic operations to check that there are two numbers on the stack before doing anything, and raising an error if this precondition is not fulfilled.\footnote{Better yet, use \ct{Object>>>assert:} to specify the preconditions for each operation.
This will arise an \ct{AssertionFailure} if you try to use the stack machine in an invalid state.}
If you do this, most  of your methods will just be one or two lines long.

\dothis{Complete the \ct{StackMachine} by writing operations \ct{dup} (push a duplicate of the top value onto the stack), \ct{exch} (exchange the top two values), and \ct{rotUp} (rotate the entire stack contents up\,---\,the top value will move to the bottom).}

Now we have a simple stack machine implementation.
We can start to implement the Seaside RPN Calculator.

We will make use of 5 classes:
\begin{itemize}
  \item \ct{RPNWidget}\,---\,this should be an abstract class that defines the common CSS stylesheet for the application
  \item \ct{RPNCalculator}\,---\,this is the root component.
  It should register the application (on the class side), it should instantiate and render its subcomponents, and it should register any state for backtracking.
  \item \ct{RPNKeyPad}\,---\,this displays the keys that we use to interact with the calculator.
  \item \ct{RPNDisplay}\,---\,this component displays the top of the stack and provides a button to call another component to display the detailed view.
  \item \ct{RPNDisplayStack}\,---\,this component shows the detailed view of the stack and provides a button to answer back.
\end{itemize}

\dothis{Define \ct{RPNWidget} and the common \ct{style}.}

Here is a minimal CSS for the application.
You can make it more fancy if you like.
\begin{code}{}
RPNWidget >>>style	^ 'table.keypad { float: left; }td.key {	border: 1px solid grey;	background: lightgrey;	padding: 4px;	text-align: center;}table.stack { float: left; }td.stackcell {	border: 2px solid white;	border-left-color: grey;	border-right-color: grey;	border-bottom-color: grey;	padding: 4px;	text-align: right;}td.small { font-size: 8pt; }'
\end{code}

\dothis{Define \ct{RPNCalculator} as the root component.
Implement \ct{RPNCalculator>>>renderContentOn:} to render something trivial, and verify that the application runs in a browser.
}

\dothis{
\ct{RPNCalculator} is responsible for instantiating \ct{StackMachine}, \ct{RPNKeyPad} and \ct{RPNDisplay}.
Define instance variables for these and define \ct{RPNCalculator>>>initialize}.
(Don't forget to send \ct{super initialize}!)
The keypad and the display will also need access to the state of the stack machine, so you should pass this when you initialize them.
To correctly display the subcomponents, you must implement \ct{RPNCalculator>>>children} to return an array with the keypad and the display.
}

\

%:===>HERE<===


Don't forget to implement \ct{RPNCalculator>>>states} to properly handle backtracking.
We need an accessor to get at the the contents of the stack machine.
Add this accessor have \ct{RPNCalculator>>>states} return an array containing the stack machine's contents.

\begin{verbatim}
- RPN Calculator
\end{verbatim}

%=================================================================
\section{Chapter summary}

\begin{itemize}
  \item 
  \item 
  \item 
  \item 
  \item 
  \item 
  \item 
  \item 
  \item 
\end{itemize}
%-----------------------------------------------------------------


%=================================================================
\ifx\wholebook\relax\else 
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=================================================================
