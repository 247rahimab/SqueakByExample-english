% $Author $
% $Date: 2007-09-25 09:59:36 +0200 (Tue, 25 Sep 2007) $
% $Revision: 12376 $
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi

\newcommand{\figlabel}[1]{\label{fig:#1}}
\newcommand{\seclabel}[1]{\label{sec:#1}}

%=================================================================
%\chapter{Versioning your Code with Monticello and SqueakSource}
\chapter{Monticello and SqueakSource}

\on{I am reviewing this chapter.}

A versioning system is a tool that helps managing concurrent access to a common source code repository. It helps to keep track of all work and all changes in a set of classes and allows several developers to collaborate. As soon as the size of your software program goes over few classes, you probably need a versioning system.

Many tools are available. CVS\footnote{\href{http://www.nongnu.org/cvs/}{www.nongnu.org/cvs}} and Subversion\footnote{\href{http://subversion.tigris.org/}{subversion.tigris.org}} are probably the most popular. Using them to manage the development of a software in Squeak will reduce the Squeak Smalltalk to a soulless file-based language. 

\emph{Monticello} is a versioning system for Squeak. It takes advantages of the Smalltalk meta-model by having a method as the software change grain. \emph{SqueakSource} is an online central repository in which you can store your application.

In this chapter, you will read about using Monticello and SqueakSource to manage your software program for day-to-day programming.

%=================================================================

\section{Basic Usage}

This section gives a brief description of the basic features of Monticello and SqueakSource: creating a packages, committing, updating and merging.

Monticello is included in the standard Squeak distribution\footnote{\href{http://www.squeak.org}{www.squeak.org}} and in the image for developers\footnote{\href{http://damien.cassou.free.fr/squeak-dev.html}{damien.cassou.free.fr/squeak-dev.html}}. If you use another image, Monticello is installable via \emph{SqueakMap} and \emph{Universe}.

Once Monticello is installed, the Monticello Browser will be available from the 'open...' menu. Open it by selecting the \emph{World} menu, then select open and press \emph{Monticello Browser}.

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{monticello.png}
	\caption{The Monticello Browser.\figlabel{monticelloMain}}
\end{figure}


\subsection{Creating a Package}

The very first thing you need is to tell Monticello about the package you want to version. Monticello packages are mapped into class categories. For example, the two classes in Quinto, the first application you have seen, are contained in the category \emph{SBE-Quinto}. Press the \emph{+Package} in the Monticello browser and enter \emph{SBE-Quinto}. Voila, you just created the \emph{SBE-Quinto} Monticello package. 

\subsection{Committing}

Before committing you need to specify \emph{where} you want to save your package. The \emph{+Repository} button is for that purpose. Choose a folder. The \emph{Save} button will save your package into this repository. You may change the version name and add a comment. 

\begin{figure}[ht]\centering
	\includegraphics[width=.55\linewidth]{saving.png}
	\caption{A new version name and a comment may be set when committing.\figlabel{saving}}
\end{figure}

\subsection{Updating}

Select the repository you want to load a version from in the list on the right-hand side of the Monticello Browser, and click the \emph{Open} button. his will open a Repository Inspector. Select your version and click the \emph{Load} button.

%\begin{figure}[ht]\centering
%	\includegraphics[width=.75\linewidth]{viewingRepository}
%	\caption{A repository offers different package versions.\figlabel{viewingRepository}}
%\end{figure}

\subsection{Using SqueakSource}

SqueakSource is a central online repository. Accessible from \href{http://www.squeaksource.com}{www.squeaksource.com}. For example, visit the BreakOut project\footnote{\href{http://www.squeaksource.com/BreakOut.html}{www.squeaksource.com/BreakOut.html}}. In the registration section you should see the 

\begin{code}

MCHttpRepository
    location: 'http://www.squeaksource.com/BreakOut'
    user: ''
    password: ''
\end{code}

Enter a new repository (press \emph{+Repository}), then select \emph{HTTP}. Fill out the template with the URL corresponding to the BreakOut project (note that you may use a cut-and-paste). Choose one version, there is a high chance that you are interested in the last version. Select one and press \emph{Load}.

Note If you want to save your code in a SqueakSource Monticello repository, the project security policy should allow you to do so.


%\begin{figure}[ht]\centering
%	\includegraphics[width=.75\linewidth]{squeaksource1}
%	\caption{SqueakSource is an online central repository.\figlabel{squeaksource1}}
%\end{figure}

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{squeaksource2}
	\caption{SqueakSource, the online Monticello code repository.\figlabel{squeaksource}}
\end{figure}

At the time this chapter is being written, about 1000 projects are registered and more than 1100 peoples have an account. \figref{squeaksource} shows the main web page.

Pressing the \emph{Register Member} menu item will probably be your very first step if you do not have a SqueakSource account. \emph{Register Project} allows for project creation. 


\subsection{Merging a with New Version}

Your package may be merged with another version by using the \emph{Merge} button in the Monticello browser. We will come back on the different options that are available at that stage. Press \emph{Merge} to replace your package with a new version of this one. Note that your change, if any, will be erased.

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{merger}
	\caption{Merging two packages is performed using a fine grain.\figlabel{merging}}
\end{figure}

\subsection{Dirty Package}

Modifying a package with the system code browser makes this package \emph{dirty}, meaning that you produced a delta with the last version that has been saved or loaded. A dirty package has its name prepended with the \emph{*} character in the Monticello browser. This is a help for the programmer to indicate which package as to be saved. Saving a dirty package cleans it.


%=================================================================

\section{Useful Features} \seclabel{monti:usefulfeatures}

Monticello has many non-vital but useful features. The Monticello browser contains 9 buttons (\figref{monticelloMain}). We already have seen 4 of them (\emph{+Package}, \emph{Save}, \emph{+Repository} and \emph{Open}). This section describes the remaining ones.

\subsection{Browse} 

As it is described in \secref{packageextension}, a Monticello package may define and redefine methods on classes defined in another package. The standard Squeak code browser does not help getting a clear view on the content of a package. The \emph{Browse} button open a package code viewer (also called snapshot browser).

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{{packageviewer}}
	\caption{The package Sound extends the class GraphMorph with 3 methods.\figlabel{packageviewer}}
\end{figure}

For example, \figref{packageviewer} shows the class extension defined in the \emph{Sound} package. This package extends the class \ct{GraphMorph} with the three methods displayed in the right most upper pane. Note that code edition is not allowed at that stage.

%\subsection{Scripts}
% Script do not work!

\subsection{History} 

The \emph{History} button opens a version history viewer that shows all package version comments for a selection. \figref{historyviewer} illustrates this situation. The list on the left hand side shows the versions of the package AST. The text pane on the right gives information about the version 140 of this package.

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{{historyviewer}}
	\caption{The version history viewer allows for crawling over different version of a package.\figlabel{historyviewer}}
\end{figure}

%Cannot do the swapping!

\subsection{Changes} 

The \emph{Changes} button computes the difference between your current package version and the last version of the package stored in the repository. 

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{{patchbrowser}}
	\caption{The patch browser shows the difference between your local version and the last committe version.\figlabel{patchbrowser}}
\end{figure}

\figref{patchbrowser} shows that the Perseus package has been locally modified with three changes. One removed method (\emph{functionName}) and two method additions (\emph{toSmalltalkCompiledMethod} on \emph{PSCompiledFunction} and \emph{PSCompiledScript}).


\subsection{Backport} 

Each package version has an ancestor which is its parent version. The left pane of the history viewer display the list of ancestor actually. \emph{Backport} allows for changing the version of a package without erasing non-commited changes. For example, let's assume you are working on the version 6 of \emph{SBE-Quinto}. This current package can be turned into the version 3 while keeping your changes. 

Backporting a package is useful when you want to revert your package to a previous while keeping your modification. You may then create a new branch. 


%=================================================================

\section{Advanced Operations} \seclabel{monti:advancedoperations}

\subsection{Branching}

You may create new version branch when saving your package. This is useful when you want to have a new parallel development. A new branch is easily created by giving a new name of the version in the upper text pane of the \emph{Edit Version} window. For example, \figref{saving} shows the package \emph{SBE-Quinto} being save. You make give a new name such as \emph{SBE-Quinto-MyBranch-ab.1} to create the branch \emph{MyBranch}. Giving a totally new name is not a great idea since it will hamper repository browsing.

\subsection{Package Extension} \seclabel{packageextension} 
Monticello packages are defined according to few naming conventions of class and method categories. A package named \emph{Foo} contains:

\begin{itemize}
\item All classes in the system category \emph{Foo}, or in system categories with names starting with \emph{Foo-}.
\item All method definitions in any class in method categories named \emph{*foo}, with names starting with \emph{*foo-}, \emph{*Foo} and \emph{*Foo-}.
\item All methods in classes in the system category \emph{Foo}, or in system categories for which their names begin with \emph{Foo-}, except those in method categories with names starting with \emph{*} (which has to belong to another modules).
\end{itemize}

\subsection{Dependencies}

A package may require another package to be properly used. Monticello supports a light weight dependency mechanism. Right-click on a package In a Monticello browser and select \emph{add required package}.

Let us assume a package \emph{A} version 1 requires another package \emph{B} version 1. This implies:

\begin{itemize}
\item Saving \emph{A} requires \emph{B} to be saved as well if \emph{B} is dirty.
\item Saving a new version of \emph{B} does \emph{not} imply saving \emph{A}.
\item Loading \emph{A} in a fresh image implies loading the version 1 of \emph{B} from the same repository where \emph{A} is loaded.
\item To make \emph{A} require a new version of \emph{B}, use the \emph{Add required package} menu item.
\end{itemize}

\subsection{Version Loading}

Loading a package with another version fully erases changes for that package that are committed. For example, let's assume that you are working on a package which contains a method \emph{m} for a class \emph{C}. Loading a new version for this package will either remove or replace your definition of \emph{C} and \emph{m}. You will not keep it, even if \emph{C} is not defined in a new version.

You probably want to use the \emph{Merge} or the \emph{Backport} if you want to update the version of your package while keeping your code change.

\begin{figure}[ht]\centering
	\includegraphics[width=.75\linewidth]{{filerepositoryinspector}}
	\caption{File Repository Inspector.\figlabel{filerepositoryinspector}}
\end{figure}

\subsection{File Repository Inspector} 
Information about the content of a repository is displayed using the File Repository Inspector triggered with the \emph{Open} button. The list of packages contained in the repository is shown on the left-hand side of the inspector:

\begin{itemize}
\item An \emph{underlined} package name means that this package is locally installed;
\item A \emph{bolded} and \emph{underlined} name means that the package is installed, but a more recent version exist in the repository.
\end{itemize}

The right-hand side enumerates the versions for the selected package:

\begin{itemize}
\item \emph{Underlined} version name means that the package is present in the system;
\item \emph{Bold} version name means that this version is not an ancestor of the local version. The bolded version belongs to a branch different than the one which is locally installed.
\end{itemize}

Note that a right click on the right-hand side of the inspector opens a menu with different sorting options.

%\subsection{Branching}
%\subsection{Ancestor}

\subsection{Class Initialization}

After being loaded, classes are initialized by Monticello by invoking the \emph{initialize} class method on classes for which this method is defined only. Note that inherited \emph{initialize} method are not invoked. 

\subsection{Adding New Variables}

Monticello supports method extension only. One way to circumvent this limitation is to define an initialize method on the class side, and manually add this variable. For example, let us image a package that extends the class \emph{OBUCommand} with a variable \emph{parent}.

\begin{code}

OBUCommand class>>initialize
	(OBUCommand instVarNames includes: 'parent') 
		ifFalse: [OBUCommand addInstVarName: 'parent']
\end{code}

In the case that \emph{initialize} is already defined in \emph{OBUCommand}, then you may define this \emph{initialize} method on a class in your package.

%=================================================================

\section{Repositories} \seclabel{monti:repositories}

Several types of repositories are supported by Monticello, each with different characteristics and uses. Repositories can be read-only, write-only or read-write.

\paragraph{HTTP} HTTP Repositories are often general purpose read-write repositories for day-to-day development using a shared server. (Although the server can be configured for read-only access. Saving Versions via HTTP uses the PUT method, wich must be enabled on the server.)

The nice thing about HTTP repositories is that it's easy to link directly to specific versions from web sites or SqueakMap. With a little configuration work on the HTTP server, HTTP repositories can be made browseable by ordinary web browsers, WebDAV clients, etc.

\paragraph{FTP} Similar to an HTTP repository, except that it uses an FTP server instead.

\paragraph{GOODS} This repository type stores Versions in a GOODS object database. It's a read-write repository, so it makes a good "working" repository where Versions can be saved and retreived. Because of the transaction support, journaling and replication capabilities of GOODS, it is suitable for large repositories used by many clients.

\paragraph{Directory} A directory repository stores Versions in a directory in the local filesystem. Since it requires very little work to set up, it's handy for private projects or disconnected development. Versions in a directory repository may be uploaded to a public or shared repository at a later time.

\paragraph{SMTP} SMTP repositories are useful for sending versions by mail. When creating an SMTP repository, you specify a destination email address. This could be the address of another developer - the package's maintainer, for example - or a mailing list such as squeak-dev. Any versions saved in such a repository will be emailed to this address.

\paragraph{SqueakMap Release} This is a write-only repository used for publishing releases of a package to SqueakMap. To configure the repository enter the name of the package on SqueakMap, your SqueakMap initials and your SqueakMap password. Now any Versions saved to the repository will be uploaded to your SqueakMap account, and registered as a new release with SqueakMap.

\paragraph{SqueakMap Cache} When packages are installed via SqueakMap, downloaded files are stored in particular location in your directory called a cache. In order to make these files available to Monticello for loading, merges etc, a SqueakMap Cache repository is created when these files are loaded for the first time.

%\paragraph{package-cache}

%The package cache is a special repository that Monticello creates automatically. Like a directory repository, the package cache stores files in a directory on your local filesystem. See Elements of Monticello for more information.

\section{The .mcz File Format}

Versions are often saved in binary files for storage in repositories, distribution to users etc. These files are commonly call 'mcz files' as they carry the extension .mcz.

\paragraph{Archive contents}

Mcz files are actually ZIP archives that follow certain conventions. Conceptually a Version contains four things:

\begin{itemize}
\item Package. A Version is related to a particular Package. Each mcz file contains a member called 'package' which contains information about the Version's Package.

\item VersionInfo. This is the meta-data about the Snapshot. It contains the author initials, date and time the Snapshot was taken, and the ancestry of the Snapshot. Each mcz file contains a member called 'version' which contains this information.
\item Snapshot. A Snapshot is a record of the state of the package at a particular time. Each mcz file contains a directory named 'snapshot/'. All the members in this directory contain definitions of program elements, which when combined form the Snapshot. Current versions of Monticello only create one member in this directory, called 'source.st'.
\item Dependencies. A Version may depend on specific Versions of other packages. An mcz file may contain a 'dependencies/' directory with a member for each dependency. These members will be named after the Package depended upon.
\end{itemize}

\paragraph{Source code encoding}

The member named 'snapshot/source.st' contains a standard fileout of the code that belongs to the package.

\paragraph{Metadata encoding}

The other memebers of the zip archive are encoded using S-expressions. Conceptually, the expressions represent nestable dictionaries. Each pair of elements in a list represent a key and value. The following example needs little explaination:

(key1 'value1' key2 (sub1 'sub value 1'))

\paragraph{Distributing mcz files}

The metadata for a Version ends up being fairly compact, so it's not unreasonable to distribute with a release. It's also important that it be present if somebody decides to start hacking on your Package. Then they can create a mcz with their Version of your package and it will have the correct ancestry information, enabling you to easily and correctly merge it back into your work.

Stated another way, a Version doesn't contain a full history of the source code. It's a snapshot of the code at a single point in time, with a UUID identifying that snapshot, and a record of the UUIDs of all the previous snapshots it's descended from. So it's a great thing to distribute.



%=================================================================

\section{Chapter Summary}

This chapter explained how to use Monticello and SqueakSource to manage the source code of your application.

\begin{itemize}
\item Monticello is used to manages your packages. Monticello is part of the Squeak standard distribution.

\item SqueakSource is a remote online central repository in which you can store your application.

\item Monticello packages are mapped into class categories. 

\item After having created a package in Monticello, you may store it in a remote repository offered by SqueakSource.

\item Monticello allows for a package version different from the local version may be merge, creating a new branch and changing the local version of your package.
\end{itemize}



%=================================================================
%=================================================================
%=================================================================
%=================================================================

%\section{Packages in Monticello: PackageInfo}

%The PackageInfo system is a simple, lightweight way of organizing Smalltalk source: it is nothing more than a naming convention, which uses (or abuses) the existing categorization mechanisms to group related code. Let me give you an example: say that you are developing a framework named SqueakLink to facilitate using relational databases from Squeak. You will probably have a series of system categories to contain all of your classes (e.g., category \cat{SqueakLink-Connections} containing the classes \ct{OracleConnection}, \ct{MySQLConnection} and \ct{PostgresConnection})
%(\cat{SqueakLink-Model} containing \ct{DBTable}, \ct{DBRow}  and \ct{DBQuery}) and so on. But not all of your code will reside in these classes - you may also have, for example, a series of methods to convert objects into an SQL friendly format: \mthind{Object}{asSQL},  \mthind{String}{asSQL} and \mthind{Date}{asSQL}.

%These methods belong in the same package as the classes in \cat{SqueakLink-Connections} and \cat{SqueakLink-Model}. You mark this by placing those methods in a method category (of \ct{Object}, \ct{String}, \ct{Date}, and so on) named \cat{*squeaklink} (note the initial star). The combination of the \cat{SqueakLink-...} system categories and the \cat{*squeaklink} method categories forms a package named "SqueakLink".

%
%\section{Getting Started}

%\paragraph{Installing}

%

%\paragraph{Creating a Working Copy}

%The first thing you need to do is tell Monticello about the package you are interested in versioning. You do this by creating a Working Copy.

%\paragraph{From an .mcz version file}
%Open a FileList and navigate to the version file. Click on the 'Load' button to load the package into your image.

%\paragraph{From scratch}

%Click on the '+Package' button, and enter the name of a PackageInfo package. It doesn't matter whether or not the code for the package already exists.

%Once the Working Copy has been created, the name of the package will appear in the package list on the left side of the Monticello Browser. If you loaded an existing version, the version name will be displayed in parenthesis after the package name, otherwise the parenthesis will be empty, indicating that your working copy has no ancestors.

%\paragraph{Connecting to a Repository}

%If you've already got a Working Copy, click on the package name on the left side of the Monticello Browser, so that your repository will be associated with your package. To connect to a repository, click on the '+Repository' button in the Monticello Browser. A pop-up menu will appear, allowing you to select the type of repository you want to connect to.

%The simplest repository type is 'directory.' When you select this type of repository, Monticello will open a FileList2 to allow you to select an existing directory in which to store versions. Other types of repositories typically require more configuration, and will open a text pane to allow you to enter it.

%\paragraph{Saving Changes}

%Changes to your working copy are automatically logged in your changes file, so you only need to create a new version of your package when you want to share the changes with others. Select the package on the left side of the Monticello Browser and the repository to save to on the right, then click the 'Save' button. See Repositories for discussion of how to publish to shared repositories.

%\paragraph{Merging Changes}

%If you or some other developer have made changes to the same version of a package, load one version as your working set and then select the repository containing the other version in the Monticello Browser, open a Repository Inspector and select the other version. Clicking the 'Merge' button will automatically load all non-conflicting changes from the other version. If you need to control which changes to accept, you may instead click 'Changes' to browse every difference.

%

%\section{Elements of Monticello}

%\paragraph{Packages}

%Packages are the units of versioning used by Monticello; the classes and methods they contain are recorded and versioned together. Monticello uses the packages defined by PackageInfo.

%\paragraph{Snapshots}

%A Snapshot is the state of a Package at a particular point in time

%\paragraph{Versions}

%A Version is a Snapshot of a Package and it's associated metadata - author initials, the date and time the snapshot was taken, and the Version's ancestry - the list of Versions from which it is derived.

%A Version is the standard currency of the system. You save them, load them, give them to others, merge them, delete... you get the picture. Versions are often stored in mcz files - see File Format

%\paragraph{Working Copies}

%Each package in an image that is being versioned with Monticello has a Working Copy. The Working Copy represents the Version of the package that is currently active in the image, and which may be modified by the Smalltalk development tools.

%\paragraph{Repositories}

%These are places to store your Versions. Unlike CVS, in which a Package is associated with one Repository, a Monticello Package can have Versions in many repositories. When adding a new Repository to use, you can choose from SqueakMap Cache, FTP, HTTP (webdav), SqueakMap Release, SMTP, or a directory somewhere on your hard drive (or network drive).

%For example, if I have six versions of package Foo, I could have Foo versions 1-4 being on my local harddrive, and 5-6 being on an ftp server. You could download version 5, make some changes and commit a new version (7) to your WebDAV repository. I can download and merge that version with my own work to produce version 8, which I save to my ftp repository.

%This is a key element of Monticello's distributed development model.

%\paragraph{Package cache}

%The package-cache is a local repository the Monticello uses to cache any package that is loaded into a particular image in a directory. That means it is filled with .mcz files, whether it is a package you create in your image, or one you download from somewhere else.

%When you use images in different directories you will have multiple package-caches, and may hold many of the same packages. If MC is loaded into an image which is subsequently moved, MC will continue to use the package-cache in the directory the image was moved from. Otherwise MC creates a new package-cache in the local directory. This can become a real mess and so some have used symlinks on unix systems to centralize it.

%\paragraph{Why cache packages at all?}

%When a Version is loaded into the image, it is likely to become the ancestor of new versions that are created as part of the development process. During merges, Monticello needs to examine the Snapshots of these ancestors in order to detect conflicts. By caching these ancestors as it loads them, MC reduces the chance that the necessary version will be unavailable - either because the repository it's in is no longer available or because it was loaded directly from a file and isn't in any repository.




%\section{The Snapshot Browser}

%The Snapshot browser is much like the standard Smalltalk System Browser except that it displays the contents of a Snapshot, rather than the code that is active in the image. Since Snapshots are immutable, the Snapshot browser does not allow editiing.

%One difference between the Snapshot Browser and the familiar system browsers is that the Snapshot browser uses the special system category '*Extensions' to categorize classes that do not belong to the package, but which have extension methods that do.
%
%\section{More on PackageInfo}
%To get a feel for this, try filing the Refactoring Browser. The Refactoring Browser code uses PackageInfo's naming conventions, using "Refactory" as the package name. In a workspace, create a model of this package with  \ct{refactory := PackageInfo named: 'Refactory'}. 

%It is now possible to introspect on this package; for example, refactory classes will return the long list of classes that make up the Refactoring Browser. refactory coreMethods will return a list of MethodReferences for all of the methods in those classes. refactory extensionMethods is perhaps one of the most interesting queries: it will return a list of all methods contained in the Refactory package but not contained within a Refactory class. This includes, for example, \mthind{String}{expandMacrosWithArguments:} and \mthind{Behavior}{parseTreeFor:}.

%Since the PackageInfo naming conventions are based on those used already by Squeak, it is possible to use it to perform analysis even of code that has not explicitly adapted to work with it. For example, (PackageInfo named: 'Collections') externalSubclasses will return a list of all Collection subclasses outside the Collections categories.

%You can send fileOut to an instance of PackageInfo to get a changeset of the entire package. For more sophisticated versioning of packages, see the Monticello project.


%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================



