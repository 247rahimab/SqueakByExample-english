% $Author: oscar $
% $Date: 2007-09-06 21:36:20 +0200 (Thu, 06 Sep 2007) $
% $Revision: 11637 $
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6in,9in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Regular Expression in Smalltalk}\label{cha:basic}


blab
This chapter is heavily based on the excellent documentation of the Regex package developed by Vassili Bybov. We thank him for letting us using this material. We present here the version 1.1 as availble on Squeaksource.com in the package named Regex. 



\section{Introduction}
A regular expression is a template specifying a class of strings. A regular 
expression matcher is an tool that determines whether a string 
belongs to a class specified by a regular expression.  This is a 
common task of a user input validation code, and the use of regular 
expressions can GREATLY simplify and speed up development of such code.  As an example, here is how to verify that a string is a valid hexadecimal number in 
Smalltalk notation, using this matcher package: \ct=aString matchesRegex: '16r[[:xdigit:]]+'=
 This matcher is offered to the Smalltalk community in hope it will be useful.
 It is free in terms of money, and to a large extent--in terms of rights of use.
 The Syntax section explains the recognized syntax of regular expressions. The 
Usage section explains matcher capabilities that go beyond what 
String>>matchesRegex: method offers.



\section{Operators}
The simplest regular expression is a single character.  It matches exactly that character. A sequence of characters matches a string with exactly the same sequence of characters:

\begin{code}{@TEST} 	
'a' matchesRegex: 'a' --> true 
'foobar' matchesRegex: 'foobar' --> true 
'blorple' matchesRegex: 'foobar' --> false
\end{code}

 The above paragraph introduced a primitive regular expression (a character), and an operator (sequencing). Operators are applied to regular expressions to 
produce more complex regular expressions. Sequencing (placing expressions one 
after another) as an operator is, in a certain sense, 'invisible'--yet it is 
arguably the most common. A more 'visible' operator is Kleene closure, more 
often simply referred to as a star (\ct{*}).  A regular expression followed by an 
asterisk matches any number (including 0) of matches of the original 
expression. For example:

\begin{code}{@TEST} 	
'ab' matchesRegex: 'a*b' --> true 
'aaaaab' matchesRegex: 'a*b' --> true 	
'b' matchesRegex: 'a*b' --> true 	
'aac' matchesRegex: 'a*b'	 --> false: b does not match
\end{code}

 A star's precedence is higher than that of sequencing. A star applies to the 
shortest possible subexpression that precedes it. For example, \ct{'ab*'}
means 'a followed by zero or more occurrences of b', not 'zero or more 
occurrences of ab':

\begin{code}{@TEST}
'abbb' matchesRegex: 'ab*' --> true 
'abab' matchesRegex: 'ab*' --> false
\end{code}

 To actually make a regex matching 'zero or more occurrences of ab', \ct{'ab'} is enclosed in parentheses:
\begin{code}{} 	
'abab' matchesRegex: '(ab)*' --> true 	
'abcab' matchesRegex: '(ab)*' --> false: c spoils the fun
\end{code} 

Two other operators similar to \ct{*} are \ct{+} and \ct{?}. 

\begin{description}
\item \ct{+} (positive closure, or simply 'plus') matches one or more occurrences of the original expression. 
\item ? (optional) matches zero or one, but never more, occurrences.
\end{description}

\begin{code}{@TEST} 	
'ac' matchesRegex: 'ab*c'	--> true 	
'ac' matchesRegex: 'ab+c'	 --> false: need at least one b 	
'abbc' matchesRegex: 'ab+c' --> true 	
'abbc' matchesRegex: 'ab?c' --> false: too many b's
\end{code}
 As we have seen, characters \ct{*}, \ct{+}, \ct{?}, \ct{(}, and \ct{)} have special meaning in regular expressions. If one of them is to be used literally, it should be quoted: preceded with a backslash \ct{\}. Thus, backslash is also special character, and needs to be quoted for a literal match--as well as any other special character described further.

\begin{code}{@TEST} 	
'ab*' matchesRegex: 'ab*' --> false     !: star in the right string is special !	
'ab*' matchesRegex: 'ab\*'	 --> true 	
'a\c' matchesRegex: 'a\\c'	--> true
\end{code} 

The last operator is pipe \ct{|} meaning or. It is placed between two regular expressions, and the resulting expression matches if one of the expressions matches. It has the lowest possible precedence lower than sequencing. For example, \ct{ab*|ba*} means 'a followed by any number of b's, or b followed by any number of a's':
\begin{code}{@TEST} 
'abb' matchesRegex: 'ab*|ba*' --> true 	
'baa' matchesRegex: 'ab*|ba*'	--> true 	
'baab' matchesRegex: 'ab*|ba*'	  --> false
\end{code} 

A bit more complex example is the following expression, matching the name of any of the Lisp-style car, cdr, caar, cadr, ... functions: 
\begin{code}{}
	c(a|d)+r
\end{code} 

It is possible to write an expression matching an empty string, for example the expression \ct{a|} matches an empty string.  However, it is an error to apply \ct{*}, \ct{+}, or \ct{?} to such an expression: \ct{(a|)*} is an invalid expression. So far, we have used only characters as the \emph{smallest} components of regular expressions. There are other, more interesting, components. A character set is a string of characters enclosed in square brackets. It matches any single character if it appears between the brackets. For example, \ct{[01]} matches either \ct{0} or \ct{1}: 

\begin{code}{@TEST}
'0' matchesRegex: '[01]' --> true 	
'3' matchesRegex: '[01]' --> false 	
'11' matchesRegex: '[01]' --> false  !a set matches only one character
\end{code}	

 Using plus operator, we can build the following binary number recognizer:

\begin{code}{@TEST} 
'10010100' matchesRegex: '[01]+' --> true 
'10001210' matchesRegex: '[01]+' --> false
\end{code}

 If the first character after the opening bracket is \^\  , the set is inverted: it matches any single character \emph{not} appearing between the brackets:

\begin{code}{@TEST} 	
'0' matchesRegex: '[^01]' --> false 	
'3' matchesRegex: '[^01]' --> true
\end{code}

For convenience, a set may include ranges: pairs of characters separated with \ct{-} (dash). This is equivalent to listing all characters between them: \ct{'[0-9]'} is the same as \ct{'[0123456789]'}. 

Special characters within a set are \^\ , \ct{-}, and \ct{]} that closes the set. Below are the examples of how to literally use them in a set: 	

\begin{code}{}
[01^]	  put the caret anywhere except the beginning 	
[01-]	  put the dash as the last character 
[]01]	  put the closing bracket as the first character  [^]01
\end{code}

Thus, empty and universal sets cannot be specified.

\paragraph{Popular classes of characters.} Regular expressions can also include the following backquote escapes to refer to popular classes of characters: 

\begin{description}	
\item \ct{\w}	any word constituent character (same as \ct{[a-zA-Z0-9...]}) 
\item \ct{\W}	any character but a word constituent 	
\item \ct{\d}	a digit (same as \ct{[0-9]}) 	
\item \ct{\D}	anything but a digit \ct{\s} a whitespace character 
\item \ct{\S} anything but a whitespace character These escapes are also allowed in character classes: \ct{[\w+-]} means 'any character that is either a word constituent, or a plus, or a minus'. 
\end{description}

\paragraph{Character classes.}
Character classes can also include the following grep(1)-compatible elements to refer to: 
\begin{description}
\item \ct{[:alnum:]}	any alphanumeric, i.e., a word constituent, character 
\item	\ct{[:alpha:]}		any alphabetic character 
\item	\ct{[:cntrl:]}		any control character. In this version, it means any character which code is \ct{< 32}. \item \ct{[:digit:]}		any decimal digit. 	
\item \ct{[:graph:]}		any graphical character. In this version, this mean any character with the code \ct{>= 32}. 	
\item \ct{[:lower:]}		any lowercase character 	
\item \ct{[:print:]}		any printable character. In this version, this is the same as \ct{[:cntrl:]}
\item \ct{[:punct:]}		any punctuation character. 
\item \ct{[:space:]}		any whitespace character. 	
\item \ct{[:upper:]}		any uppercase character. 	
\item \ct{[:xdigit:]}		any hexadecimal character.
\end{description}


Note that these elements are components of the character classes, \ie they have to be enclosed in an extra set of square brackets to form a valid regular expression.  For example, a non-empty string of digits would be represented as \ct{[[:digit:]]+}. The above primitive expressions and operators are common to many implementations of regular expressions. 

\paragraph{} The next primitive expression is unique to this Smalltalk implementation. A sequence of characters between colons is treated as a unary selector which is supposed to be understood by Characters. A character matches such an expression if it answers true to a message with that selector. This allows a more readable and efficient way of specifying character classes. For example, \ct{[0-9]} is equivalent to \ct{:isDigit:}, but the latter is more efficient. Analogously to character sets, character classes can be negated: \ct{:^isDigit:} matches a Character that answers \ct{false} to \ct{isDigit}, and is therefore equivalent to \ct{[^0-9]}. 

As an example, so far we have seen the following equivalent ways to write a regular expression that matches a non-empty string of digits: \ct{[0-9]+}, \ct{\d+}, \ct{[\d]+}, \ct{[[:digit:]+} \sd{check this one}, \ct{:isDigit:+}.

\paragraph{Special primitives expressions.} 
The last group of special primitive expressions includes:  	

\begin{description}
\item \ct{. (period)}	matching any character except a newline.  
\item \^\  	matching an empty string at the beginning of a line.  
\item \$\	matching an empty string at the end of a line. 	
\item \ct{\b} an empty string at a word boundary. 	
\item \ct{\B} an empty string not at a word boundary. 	
\item \ct{\<} an empty string at the beginning of a word. 	
\item \ct{\>} an empty string at the end of a word. 
\end{description}

\begin{code}{@TEST}
'axyzb' matchesRegex: 'a.+b' --> true 	
'ax zb' matchesRegex: 'a.+b' --> false     (space is not matched by . (period). 
\end{code}

Again, all the above three characters are special and should be quoted to be matched literally. 	

\section{Examples} 

As the introductions said, a great use for regular expressions is user input validation. Following are a few examples of regular expressions that might be handy in checking input entered by the user in an input field. Try them out by entering something between the quotes and print-iting. Also, try to imagine Smalltalk code that each validation would require if coded by hand.  Most example expressions could have been written in alternative ways.
\sd{should add examples for each case}


 Checking if aString may represent a nonnegative integer number: 
 \begin{code}	
 '' matchesRegex: ':isDigit:+' or 	
 '' matchesRegex: '[0-9]+' or 	
 '' matchesRegex: '\d+' 
 \end{code}
 
 \sd{should add examples with '12' et '-13'}
 
 Checking if aString may represent an integer number with an optional sign in front: 
 \begin{code}{}
'' matchesRegex: '(\+|-)?\d+' 
 \end{code}
 
Checking if aString is a fixed-point number, with at least one digit is required after a dot: 

\begin{code}{}
'' matchesRegex: '(\+|-)?\d+(\.\d+)?' 
The same, but allow notation like '123.': 
'' matchesRegex: '(\+|-)?\d+(\.\d*)?' 
\end{code} 
 
Recognizer for a string that might be a name: one word with first capital letter, no blanks, no digits.  More traditional: 	
\begin{code}{}
'' matchesRegex: '[A-Z][A-Za-z]*' 

more Smalltalkish: 	
'' matchesRegex: ':isUppercase::isAlphabetic:*'
\end{code}
 
 
  A date in format MMM DD, YYYY with any number of spaces in between, in XX century: 
  
  \begin{code}{}
'' matchesRegex: '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(\d\d?)[ ]*,[ ]*19(\d\d)' 
\end{code}

Note parentheses around some components of the expression above. As the Usage Section shows, they will allow us to obtain the actual strings that have matched them (\ie month name, day number, and year number). 


For dessert, coming back to numbers: here is a recognizer for a general number format: anything like \ct{999}, or \ct{999.999}, or \ct{-999.999e+21}. 	

\begin{code}{}
'' matchesRegex: '(\+|-)?\d+(\.\d*)?((e|E)(\+|-)?\d+)?'
\end{code}



\section{Prefix Matching And Case-Insensitive Matching}
The preceding section covered the syntax of regular expressions. It used the 
simplest possible interface to the matcher: sending \mthind{matchesRegex:}{matchesRegex:} message to the sample string, with regular expression string as the argument. This section explains hairier ways of using the matcher. 	

A \clsind{CharacterArray}  also understands these messages: 	
\ct{prefixMatchesRegex: regexString}, \ct{matchesRegexIgnoringCase: regexString} 
\ct{prefixMatchesRegexIgnoringCase: regexString}, \ct{prefixMatchesRegex:} is just like \ct{matchesRegex}, except that the whole receiver is not expected to match the regular expression passed as the argument; matching just a prefix of it is enough.  

\sd{should use mthind}
	
\begin{code}{}
'abcde' matchesRegex: '(a|b)+' --> false 	
'abcde' prefixMatchesRegex: '(a|b)+' --> true The last two messages are case-insensitive versions of matching. 	
\end{code}


\section{Enumeration Interface}

An application can be interested in all matches of a certain regular expression within a String.  The matches are accessible using a protocol modelled after the familiar Collection-like enumeration protocol: 

\begin{description}
\item \ct{regex: regexString matchesDo: aBlock} Evaluates a one-argument <aBlock> for every match of the regular expression within the receiver string. 

\item \ct{regex: regexString matchesCollect: aBlock}
  Evaluates a one-argument \ct{aBlock} for every match of the regular expression within the receiver string. Collects results of evaluations and anwers them as a \clsind{SequenceableCollection}. \sd{strange bug latex}
  
\item \ct{allRegexMatches: regexString} Returns a collection of all matches (substrings of the receiver string) of the regular expression.  It is an equivalent of \ct{aString regex: regexString matchesCollect: [:each | each]}. 
\end{description}

\sd{Missing examples}


\section{Replacement and Translation}

It is possible to replace all matches of a regular expression with a certain string using the message: 	\ct{copyWithRegex: regexString matchesReplacedWith: aString}

\begin{code}{}
'ab cd ab' copyWithRegex: '(a|b)+' matchesReplacedWith: 'foo' 
\end{code}


A more general substitution is match translation: \mthind{copyWithRegex: regexString matchesTranslatedUsing: aBlock}{copyWithRegex: regexString matchesTranslatedUsing: aBlock}. This message evaluates a block passing it each match of the regular expression in the receiver string and answers a copy of the receiver with the block results spliced into it in place of the respective matches.  

\begin{code}{}
'ab cd ab' copyWithRegex: '(a|b)+' matchesTranslatedUsing: [:each | each asUppercase] 
\end{code}



All messages of enumeration and replacement protocols perform a case-sensitive match.  Case-insensitive versions are not provided as part of a \ct{CharacterArray} protocol.  Instead, they are accessible using the lower-level matching interface presented in the following question. 	

\section{Lower-Level Interface}

Internally, \mthind{matchesRegex:}{matchesRegex:}  works as follows: 

\begin{enumerate}
\item A fresh instance of \clsind{RxParser} is created, and the regular expression string is passed to it, yielding the expression's syntax tree. 
\item  The syntax tree is passed as an initialization parameter to an instance of \clsind{RxMatcher}. The instance sets up some data structure that will work as a recognizer for the regular expression described by the tree. 
\item The original string is passed to the matcher, and the matcher checks for a match. 
\end{enumerate}	




\subsection{The Matcher}
If you repeatedly match a number of strings against the same regular expression using one of the messages defined in \clsind{CharacterArray}, the regular expression string is parsed and a matcher is created anew for every match.  You can avoid this overhead by building a matcher for the regular expression, and then reusing the matcher over and over again. You can, for example, create a matcher at a class or instance initialization stage, and store it in a variable for future use. 

You can create a matcher using one of the following methods: 	

\begin{itemize} 

\item Sending \mthind{forString:ignoreCase:}{forString:ignoreCase:} message to \clsind{RxMatcher} class, with the regular expression string and a Boolean indicating whether case is ignored as arguments. 	
\item Sending \mthind{forString:}{forString:} message.  It is equivalent to \ct{forString: regexString ignoreCase: false}. A more convenient way is using one of the two matcher-created messages understood by \clsind{CharacterArray}. 	 \ct{regexString asRegex} is equivalent to \ct{RxMatcher forString: regexString}. 	 \ct{regexString asRegexIgnoringCase} is equivalent to \ct{RxMatcher forString: regexString ignoreCase: true}. 

\end{itemize}
Here are four examples of creating a matcher: 	

\begin{code}{}
hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+' 	
hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+' ignoreCase: false 
hexRecognizer := '16r[0-9A-Fa-f]+' asRegex 	
hexRecognizer := '16r[0-9A-F]+' asRegexIgnoringCase
\end{code}



\section{Matching}

The matcher understands these messages (all of them return \ct{true} to indicate successful match or search, and false otherwise): 

\begin{description}
\item \ct{matches: aString} True if the whole target string (aString) matches. 

\item \ct{matchesPrefix: aString} True if some prefix of the string (not necessarily the whole string) matches. 

\item \ct{search: aString} Search the string for the first occurrence of a matching substring. (Note that the first two methods only try matching from 	the very beginning of the string). Using the above example with a  matcher for \ct{a+}, this method would answer success given a string \ct{'baaa'}, while the previous two would fail. 

\item \ct{matchesStream: aStream matchesStreamPrefix: aStream searchStream: aStream} Respective analogs of the first three methods, taking input from a stream instead of a string. The stream must be positionable and peekable. All these methods answer a boolean indicating success.

\item  The matcher also stores the outcome of the last match attempt and can report it: 
\ct{lastResult} answers a Boolean: the outcome of the most recent match attempt. If no matches were attempted, the answer is unspecified. 

\end{description}



\subsection{Subexpression Matches}

 After a successful match attempt, you can query the specifics of which part of the original string has matched which part of the whole expression. A subexpression is a parenthesized part of a regular expression, or the whole expression. When a regular expression is compiled, its subexpressions are assigned indices starting from 1, depth-first, left-to-right. 
 
 For example, \ct{((ab)+(c|d))?ef} includes the following subexpressions with these indices: 

\begin{code}{}
 1:	((ab)+(c|d))?ef 	2:	(ab)+(c|d) 	3:	ab 	4:	c|d
\end{code}


 
  After a successful match, the matcher can report what part of the original string matched what subexpression. It understandards these messages: 
  
 \begin{description}
\item \ct{subexpressionCount} 	Answers the total number of subexpressions: the highest value that can be used as a subexpression index with this matcher. This value 	is available immediately after initialization and never changes. 

\item \mthind{subexpression: anIndex} An index must be a valid subexpression index, and this message must be sent only after a successful match attempt. The method answers a substring of the original string the corresponding subexpression has matched to. 

\item \ct{subBeginning: anIndex subEnd: anIndex} Answer positions within the original string or stream where the 	match of a subexpression with the given index has started and ended, respectively. This facility provides a convenient way of extracting parts of input strings of complex format. 
\end{description}




For example, the following piece of code uses the \ct{MMM DD, YYYY} date format recognizer example from the 'Syntax' section to convert a date to a three-element array with year, month, and day strings (you can select and evaluate it right here): 	

\begin{code}{}
| matcher | 	
matcher := RxMatcher forString:  '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(:isDigit::isDigit:?)[ ]*,[ ]*19(:isDigit::isDigit:)'. 	
(matcher matches: 'Aug 6, 1996') 		
       ifTrue: [Array 
                       with: (matcher subexpression: 4) 	with: (matcher subexpression: 2) 				with: (matcher subexpression: 3)] 		
        ifFalse: ['no match'] (should answer ' #('96' 'Aug' '6')'). 	
\end{code}        
        


        
\section{Enumeration and Replacement}

 The enumeration and replacement protocols exposed in \clsind{CharacterArray} are actually implemented by the mather.  The following messages are understood: 
 
 \begin{itemize}
\item \ct{matchesIn: aString} 	
\item \ct{matchesIn: aString do: aBlock} 	
\item \ct{matchesIn: aString collect: aBlock} 	
\item \ct{copy: aString replacingMatchesWith: replacementString}
\item \ct{copy: aString translatingMatchesUsing: aBlock} 	
\item \ct{matchesOnStream: aStream} 	
\item \ct{matchesOnStream: aStream do: aBlock} 
\item \ct{matchesOnStream: aStream collect: aBlock} 	
\item \ct{copy: sourceStream to: targetStream replacingMatchesWith: replacementString}
\item \ct{copy: sourceStream to: targetStream translatingMatchesWith: aBlock} 
\end{itemize}	
	
\sd{some examples}
	
\section{Error Handlling}		
Exception signaling objects are accessible through \clsind{RxParser} class protocol. To handle possible errors, use the protocol described below to obtain the exception objects and use the protocol of the native Smalltalk implementation to handle them. If a syntax error is detected while parsing expression, \mthind{RxParser>>syntaxErrorSignal} is raised/signaled. If an error is detected while building a matcher, \mthind{RxParser>>compilationErrorSignal} is raised/signaled. If an error is detected while matching (for example, if a bad selector was specified using ':<selector>:' syntax, or because of the matcher's internal error), \mthind{RxParser>>matchErrorSignal} is raised \mthind{RxParser>>regexErrorSignal} is the parent of all three.  Since any of the three signals can be raised within a call to \mthind{matchesRegex:}, it is handy if you want to catch them all.  For example: VisualWorks: 	

\sd{to check for Squeak}
\begin{code}{}
RxParser regexErrorSignal 
   handle: [:ex | ex returnWith: nil]
   do: ['abc' matchesRegex: '))garbage['] 
\end{code}



\section{Implementation Notes}

\paragraph{What to look at first.} In 90\% cases this method \mthind{String>>matchesRegex:}  is all you need to access the package. RxParser accepts a string or a stream of characters with a regular expression, and produces a syntax tree corresponding to the expression. The tree is made of instances of \clsind{Rxs} classes. \clsind{RxMatcher}  accepts a syntax tree of a regular expression built by the parser and compiles it into a matcher: a structure made of instances of \clsind{Rxm} classes. The \clsind{RxMatcher} instance can test whether a string or a positionable stream of characters matches the original regular expression, or search a string or a stream for substrings matching the expression. After a match is found, the matcher can report a specific string that matched the whole expression, or any parenthesized subexpression of it. All other classes support the above functionality and are used by \clsind{RxParser}, \clsind{RxMatcher}, or both. 	

\paragraph{Caveats.} The matcher is similar in spirit, but NOT in the design--let alone the code--to the original Henry Spencer's regular expression implementation in C.  The focus is on simplicity, not on efficiency. I didn't optimize or profile anything.  I may in future--or I may not: I do this in my spare time and I don't promise anything. The matcher passes H. Spencer's test suite (see 'test suite' protocol), with quite a few extra tests added, so chances are good there are not too many bugs.  But watch out anyway. 	


\paragraph{Acknolegdements from Vassili Bykov.}
 Since the first release of the matcher, thanks to the input from several fellow Smalltalkers, I became convinced a native Smalltalk regular expression matcher was worth the effort to keep it alive. For the advice and encouragement that made this release possible, I want to thank: Felix Hack, Eliot Miranda, Robb Shecter, David N. Smith, Francis Wolinski and anyone whom I haven't yet met or heard from, but who agrees this has not been a complete waste of time.

(Coding the same ''the hard way'' is an exercise to a curious reader).

\end{document}

%=============================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=============================================================


what was new in 1.1
 1. Backslash escapes similar to those in Perl are allowed in patterns: 	\w	any word constituent character (equivalent to [a-zA-Z0-9_]) 	\W	any character but a word constituent (equivalent to [^a-xA-Z0-9_] 	\d	a digit (same as [0-9]) 	\D	anything but a digit 	\s 	a whitespace character 	\S	anything but a whitespace character 	\b	an empty string at a word boundary 	\B	an empty string not at a word boundary 	\<	an empty string at the beginning of a word 	\>	an empty string at the end of a word For example, '\w+' is now a valid expression matching any word. 2. The following backslash escapes are also allowed in character sets (between square brackets): 	\w, \W, \d, \D, \s, and \S. 3. The following grep(1)-compatible named character classes are recognized in character sets as well: 	[:alnum:] 	[:alpha:] 	[:cntrl:] 	[:digit:] 	[:graph:] 	[:lower:] 	[:print:] 	[:punct:] 	[:space:] 	[:upper:] 	[:xdigit:] For example, the following patterns are equivalent: 	'[[:alnum:]]+' '\w+'  '[\w]+' '[a-zA-Z0-9_]+' 4. Some non-printable characters can be represented in regular expressions using a common backslash notation: 	\t	tab (Character tab) 	\n	newline (Character lf) 	\r	carriage return (Character cr) 	\f	form feed (Character newPage) 	\e	escape (Character esc) 5. A dot is corectly interpreted as 'any character but a newline' instead of 'anything but whitespace'. 6. Case-insensitive matching.  The easiest access to it are new messages CharacterArray understands: #asRegexIgnoringCase, #matchesRegexIgnoringCase:, #prefixMatchesRegexIgnoringCase:. 7. The matcher (an instance of RxMatcher, the result of String>>asRegex) now provides a collection-like interface to matches in a particular string or on a particular stream, as well as substitution protocol. The interface includes the following messages: 	matchesIn: aString 	matchesIn: aString collect: aBlock 	matchesIn: aString do: aBlock 	matchesOnStream: aStream 	matchesOnStream: aStream collect: aBlock 	matchesOnStream: aStream do: aBlock 	copy: aString translatingMatchesUsing: aBlock 	copy: aString replacingMatchesWith: replacementString 	copyStream: aStream to: writeStream translatingMatchesUsing: aBlock 	copyStream: aStream to: writeStream replacingMatchesWith: aString Examples: 	'\w+' asRegex matchesIn: 'now is the time' returns an OrderedCollection containing four strings: 'now', 'is', 'the', and 'time'. 	'\<t\w+' asRegexIgnoringCase 		copy: 'now is the Time' 		translatingMatchesUsing: [:match | match asUppercase] returns 'now is THE TIME' (the regular expression matches words beginning with either an uppercase or a lowercase T). 


EXTENSIONS, FUTURE, ETC. With the existing separation between the parser, the syntax tree, and the matcher, it is easy to extend the system with other matchers based on other algorithms. In fact, I have a DFA-based matcher right now, but I don't feel it is good enough to include it here.  I might add automata-based matchers later, but again I don't promise anything. 	

HOW TO REACH ME As of today (October 3, 1999), you can contact me at <vassili@objectpeople.com>. If this doesn't work, look around comp.lang.smalltalk and comp.lang.lisp.



%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: